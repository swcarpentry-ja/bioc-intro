---
source: Rmd
title: Prochaines étapes
teaching: 45
exercises: 45
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- Présentez le projet Bioconducteur.
- Introduire la notion de conteneurs de données.
- Donnez un aperçu du `SummarizedExperiment`, largement utilisé dans les analyses
  omiques.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Qu'est-ce qu'une « expérience résumée » ?
- Qu’est-ce qu’un bioconducteur ?

::::::::::::::::::::::::::::::::::::::::::::::::

## Prochaines étapes

```{r, echo=FALSE, message=FALSE}
bibliothèque("tidyverse")
```

Les données en bioinformatique sont souvent complexes.  Pour résoudre ce problème, les développeurs
définissent des conteneurs de données spécialisés (appelés classes) qui
correspondent aux propriétés des données qu'ils doivent gérer.

Cet aspect est au cœur du projet **Bioconductor**[^Bioconductor]
qui utilise la même **infrastructure de données de base** dans tous les packages. Ce
a certainement contribué au succès de Bioconductor. Il est conseillé aux développeurs du package Bioconductor
d'utiliser l'infrastructure existante pour
assurer la cohérence, l'interopérabilité et la stabilité du projet dans son ensemble
.

[^Bioconductor]: Le [Bioconductor](https://www.bioconductor.org) a été
    initié par Robert Gentleman, l'un des deux créateurs du langage R
    . Bioconductor fournit des outils dédiés à l'analyse des données omiques
    . Bioconductor utilise le langage de programmation statistique R
    et est open source et développement ouvert.

Pour illustrer un tel conteneur de données omiques, nous présenterons la classe
`SummarizedExperiment`.

## Expérience résumée

La figure ci-dessous représente l’anatomie de la classe SummarizedExperiment.

```{r SE, echo=FALSE, out.width="80%"}
knitr::include_graphics("https://uclouvain-cbio.github.io/WSBIM1322/figs/SE.svg")
```

Les objets de la classe SummarizedExperiment contiennent :

- **Un (ou plusieurs) test(s)** contenant les données omiques quantitatives
  (données d'expression), stockées sous forme d'objet de type matriciel. Caractéristiques (gènes,
  transcrits, protéines, ...) sont définis le long des lignes, et les échantillons
  le long des colonnes.

- Un emplacement **exemple de métadonnées** contenant des exemples de covariables, stocké sous forme de trame de données
  . Les lignes de ce tableau représentent des échantillons (les lignes correspondent exactement aux colonnes
  des données d'expression).

- Un emplacement de **métadonnées de fonctionnalité** contenant des covariables de fonctionnalité, stockées sous forme de
  une trame de données. Les lignes de ce bloc de données correspondent exactement aux lignes des données d'expression
  .

La nature coordonnée du `SummarizedExperiment` garantit que
lors de la manipulation des données, les dimensions des différents emplacements seront toujours
(c'est-à-dire les colonnes des données d'expression puis les lignes de
les exemples de métadonnées, ainsi que les lignes des données d'expression et les
métadonnées des fonctionnalités) lors de la manipulation des données. Par exemple, si nous devions
exclure un échantillon du test, il serait automatiquement supprimé
des métadonnées de l’échantillon au cours de la même opération.

Les emplacements de métadonnées peuvent développer des co-variables supplémentaires
(colonnes) sans affecter les autres structures.

### Création d'une expérience résumée

Afin de créer un `SummarizedExperiment`, nous allons créer les
composants individuels, c'est-à-dire la matrice de comptage, l'échantillon et le gène
métadonnées à partir de fichiers csv. C'est généralement ainsi que les données RNA-Seq sont
fournies (après le traitement des données brutes).

```{r, echo=FALSE, message=FALSE}
rna <- read_csv("data/rnaseq.csv")

## count matrix
counts <- rna %>%
  select(gene, sample, expression) %>%
  pivot_wider(names_from = sample,
              values_from = expression)

## convert to matrix and set row names
count_matrix <- counts %>% select(-gene) %>% as.matrix()
rownames(count_matrix) <- counts$gene

## sample annotation
sample_metadata <- rna %>%
  select(sample, organism, age, sex, infection, strain, time, tissue, mouse)

## remove redundancy
sample_metadata <- unique(sample_metadata)

## gene annotation
gene_metadata <- rna %>%
  select(gene, ENTREZID, product, ensembl_gene_id, external_synonym,
         chromosome_name, gene_biotype, phenotype_description,
         hsapiens_homolog_associated_gene_name)

# remove redundancy
gene_metadata <- unique(gene_metadata)

## write to csv
write.csv(count_matrix, file = "data/count_matrix.csv")
write.csv(gene_metadata, file = "data/gene_metadata.csv", row.names = FALSE)
write.csv(sample_metadata, file = "data/sample_metadata.csv", row.names = FALSE)
```

- **Une matrice d'expression** : nous chargeons la matrice de comptage, en spécifiant que
  les premières colonnes contiennent des noms de lignes/gènes, et convertissons le
  `data.frame` en une `matrice`. Vous pouvez le télécharger
  [ici](https://carpentries-incubator.github.io/bioc-intro/data/count_matrix.csv).

```{r}
count_matrix <- read.csv("data/count_matrix.csv",
                         row.names = 1) %>%
    as.matrix()

count_matrix[1:5, ]
dim(count_matrix)
```

- **Un tableau décrivant les échantillons**, disponible
  [ici](https://carpentries-incubator.github.io/bioc-intro/data/sample_metadata.csv).

```{r}
sample_metadata <- read.csv("data/sample_metadata.csv")
sample_metadata
dim(sample_metadata)
```

- **Un tableau décrivant les gènes**, disponible
  [ici](https://carpentries-incubator.github.io/bioc-intro/data/gene_metadata.csv).

```{r}
gene_metadata <- read.csv("data/gene_metadata.csv")
gene_metadata[1:10, 1:4]
dim(gene_metadata)
```

Nous allons créer un `SummarizedExperiment` à partir de ces tables :

- La matrice de comptage qui sera utilisée comme **`essai`**

- Le tableau décrivant les échantillons sera utilisé comme emplacement de métadonnées \*\*sample
  \*\*

- Le tableau décrivant les gènes sera utilisé comme emplacement de métadonnées \*\*features
  \*\*

Pour ce faire, nous pouvons assembler les différentes parties à l'aide du constructeur
`SummarizedExperiment` :

```{r, message=FALSE, warning=FALSE}
## BiocManager::install("SummarizedExperiment")
bibliothèque("SummarizedExperiment")
```

Tout d’abord, nous nous assurons que les échantillons sont dans le même ordre dans la matrice de comptage
et l’annotation d’échantillon, et il en va de même pour les gènes dans
la matrice de comptage et l’annotation des gènes.

```{r}
stopifnot(rownames(count_matrix) == gene_metadata$gene)
stopifnot(colnames(count_matrix) == sample_metadata$sample)
```

```{r}
se <- SummarizedExperiment(assays = list(counts = count_matrix),
                           colData = sample_metadata,
                           rowData = gene_metadata)
se
```

### La sauvegarde des données

L'export de données vers un tableur, comme nous l'avons fait dans un épisode précédent, présente
plusieurs limitations, comme celles décrites dans le premier chapitre
(éventuelles incohérences avec `,` et `.` pour les séparateurs décimaux et
manque de définitions de types de variables). De plus, l'exportation de données vers une feuille de calcul
n'est pertinente que pour les données rectangulaires telles que les dataframes
et les matrices.

Une manière plus générale de sauvegarder des données, spécifique à R et dont le fonctionnement est
garanti sur n'importe quel système d'exploitation, consiste à utiliser la fonction `saveRDS`
. L'enregistrement d'objets comme celui-ci générera une représentation binaire
sur le disque (en utilisant l'extension de fichier `rds` ici), qui
peut être rechargée dans R à l'aide de la fonction `readRDS`.

```{r, eval=FALSE}
saveRDS(se, file = "data_output/se.rds")
rm(se)
se <- readRDS("data_output/se.rds")
head(se)
```

Pour conclure, lorsqu'il s'agit de sauvegarder des données de R qui seront chargées
à nouveau dans R, la sauvegarde et le chargement avec `saveRDS` et `readRDS` sont l'approche
préférée. Si les données tabulaires doivent être partagées avec quelqu'un
qui n'utilise pas R, alors l'exportation vers une feuille de calcul textuelle est une
bonne alternative.

En utilisant cette structure de données, nous pouvons accéder à la matrice d'expression avec
la fonction `assay` :

```{r}
head(essai(se))
dim(essai(se))
```

Nous pouvons accéder aux exemples de métadonnées à l'aide de la fonction `colData` :

```{r}
colData(se)
dim(colData(se))
```

Nous pouvons également accéder aux métadonnées des fonctionnalités à l'aide de la fonction `rowData` :

```{r}
head(rowData(se))
dim(rowData(se))
```

### Sous-ensemble d'une expérience résumée

SummarizedExperiment peut être un sous-ensemble comme avec des trames de données, avec des chiffres
ou avec des caractères logiques.

Ci-dessous, nous créons une nouvelle instance de la classe SummarizedExperiment qui
contient uniquement les 5 premières fonctionnalités pour les 3 premiers échantillons.

```{r}
se1 <- se[1:5, 1:3]
se1
```

```{r}
colData(se1)
rowData(se1)
```

Nous pouvons également utiliser la fonction `colData()` pour créer un sous-ensemble sur quelque chose de
les exemples de métadonnées ou la fonction `rowData()` pour créer un sous-ensemble sur quelque chose à partir des métadonnées de fonctionnalité
.  Par exemple, nous ne conservons ici que les miARN et les échantillons non
infectés :

```{r}
se1 <- se[rowData(se)$gene_biotype == "miRNA",
          colData(se)$infection == "NonInfected"]
se1
assay(se1)
colData(se1)
rowData(se1)
```

<!--For the following exercise, you should download the SE.rda object
(that contains the `se` object), and open the file using the 'load()'
function.-->

<!-- ```{r, eval = FALSE, echo = FALSE} -->

<!-- download.file(url = "https://raw.githubusercontent.com/UCLouvain-CBIO/bioinfo-training-01-intro-r/master/data/SE.rda", -->

<!--               destfile = "data/SE.rda") -->

<!-- load("data/SE.rda") -->

<!-- ``` -->

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Extraire les niveaux d'expression génique des 3 premiers gènes dans les échantillons
au temps 0 et au temps 8.

:::::::::::::::  solution

## Solution

```{r, purl=FALSE}
assay(se)[1:3, colData(se)$time != 4]

# Equivalent to
assay(se)[1:3, colData(se)$time == 0 | colData(se)$time == 8]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Défi

Vérifiez que vous obtenez les mêmes valeurs en utilisant la longue table `rna`.

:::::::::::::::  solution

## Solution

```{r, purl=FALSE}
arn |>
    filtre(gène %in% c("Asl", "Apod", "Cyd2d22")) |>
    filtre(temps != 4) |> select(expression )
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Le long tableau et le `SummarizedExperiment` contiennent les mêmes informations
, mais sont simplement structurés différemment. Chaque approche a ses
propres avantages : la première convient bien aux packages `tidyverse`,
tandis que la seconde est la structure préférée pour de nombreuses étapes de bioinformatique et
de traitement statistique. Par exemple, une analyse typique d'ARN-Seq utilisant
le package `DESeq2`.

#### Ajouter des variables aux métadonnées

Nous pouvons également ajouter des informations aux métadonnées.
Supposons que vous souhaitiez ajouter le centre où les échantillons ont été collectés...

```{r}
colData(se)$center <- rep("Université de l'Illinois", nrow(colData(se)))
colData(se)
```

Cela illustre que les emplacements de métadonnées peuvent croître indéfiniment sans
affecter les autres structures !

### TidyRésuméExpérience

Vous vous demandez peut-être si pouvons-nous utiliser les commandes Tidyverse pour interagir avec les objets
`SummarizedExperiment` ? La réponse est oui, nous pouvons le faire avec le package
`tidySummarizedExperiment`.

Rappelez-vous à quoi ressemble notre objet SummarizedExperiment :

```{r, message=FALSE}
se
```

Chargez `tidySummarizedExperiment` puis jetez à nouveau un œil à l'objet se
.

```{r, message=FALSE}
#BiocManager::install("tidySummarizedExperiment")
library("tidySummarizedExperiment")

se
```

Il s'agit toujours d'un objet `SummarizedExperiment`, il conserve donc la structure efficace
, mais nous pouvons maintenant le voir comme un tibble. Notez la première ligne de
la sortie dit ceci, c'est une abstraction `SummarizedExperiment`\-`tibble`
. Nous pouvons également voir dans la deuxième ligne de la sortie le nombre
de transcriptions et d'échantillons.

Si nous voulons revenir à la vue standard `SummarizedExperiment`, nous
pouvons le faire.

```{r}
options("restore_SummarizedExperiment_show" = TRUE)
se
```

Mais ici, nous utilisons la vue tibble.

```{r}
options("restore_SummarizedExperiment_show" = FALSE)
se
```

Nous pouvons maintenant utiliser les commandes Tidyverse pour interagir avec l'objet
`SummarizedExperiment`.

Nous pouvons utiliser `filter` pour filtrer les lignes en utilisant une condition, par exemple pour afficher
toutes les lignes pour un échantillon.

```{r}
se %>% filtre(.sample == "GSM2545336")
```

Nous pouvons utiliser « select » pour spécifier les colonnes que nous voulons afficher.

```{r}
se %>% sélectionner (.sample)
```

Nous pouvons utiliser `mutate` pour ajouter des informations sur les métadonnées.

```{r}
se %>% muter(center = "Université de Heidelberg")
```

Nous pouvons également combiner des commandes avec le tube Tidyverse `%>%`. Pour l'exemple de
, nous pourrions combiner `group_by` et `summarise` pour obtenir le nombre total de
pour chaque échantillon.

```{r}
se %>%
    group_by(.sample) %>%
    summarise(total_counts=sum(counts))
```

Nous pouvons traiter l'objet SummarizedExperiment bien rangé comme un tibble normal
pour le traçage.

Ici, nous traçons la distribution des comptes par échantillon.

```{r tidySE-plot}
se %>%
    ggplot(aes(counts + 1, group=.sample, color=infection)) +
    geom_density() +
    scale_x_log10() +
    theme_bw()
```

Pour plus d'informations sur TidySummarizedExperiment, consultez le site Web du package[ici](https://stemangiola.github.io/tidySummarizedExperiment/).

**Message à retenir**

- `SummarizedExperiment` représente un moyen efficace de stocker et
  de gérer les données omiques.

- Ils sont utilisés dans de nombreux packages Bioconductor.

Si vous suivez la prochaine formation axée sur l'analyse de séquençage d'ARN,
vous apprendrez à utiliser le package Bioconductor `DESeq2` pour faire des
analyses d'expression différentielle.  L'ensemble de l'analyse du package `DESeq2`
est géré dans un `SummarizedExperiment`.

:::::::::::::::::::::::::::::::::::::::: keypoints

- Bioconductor est un projet fournissant un support et des packages pour la
  compréhension de données biologiques à haut débit.
- Un `SummarizedExperiment` est un type d'objet utile pour stocker et
  gérer des données omiques à haut débit.

::::::::::::::::::::::::::::::::::::::::::::::::::
