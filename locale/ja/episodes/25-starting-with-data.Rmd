---
source: Rmd
title: データから始める
teaching: 30
exercises: 30
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- `data.frame` が何なのか説明してみましょう。
- .csv ファイルからデータ フレームに外部データを読み込みましょう。
- データフレームの内容を要約してみましょう。
- ファクターとは何か？
- string と factor を変換してみましょう。
- factor の並び替えとリネームを行ってみましょう。
- 日付をフォーマットしてみましょう。
- データをエクスポートして保存してみましょう。

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Rによる最初のデータ分析

::::::::::::::::::::::::::::::::::::::::::::::::::

> このエピソードは、Data Carpentriesの_Data Analysis and
> Visualisation in R for Ecologists_レッスンに基づいています。

## 遺伝子発現データのプレゼンテーション

Blackmore _et al._
(2017)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5544260/), _The
effect of upper-respiratory infection on transcriptomic changes in
CNS_ によって発表されたデータの一部を使用する予定である。 研究の目的は、
上部呼吸器感染症が、感染後の小脳と脊髄で
起こるRNA転写の変化に及ぼす影響を調べることであった。 性別を一致させた8匹の
週齢のC57BL/6マウスに、生理食塩水または
鼻腔内経路でインフルエンザAを接種し、0日目
（非感染）、4日目、8日目に小脳と
脊髄組織におけるトランスクリプトーム変化をRNA-seqで評価した。

データセットは、カンマ区切りの値（CSV）ファイルとして保存される。  各行
は1つのRNA発現測定の情報を持ち、最初の11列
はそれを表している：

| コラム  | 説明                                       |
| ---- | ---------------------------------------- |
| 遺伝子  | 測定された遺伝子名                                |
| サンプル | 遺伝子発現を測定したサンプル名                          |
| 表現   | 遺伝子発現の値                                  |
| 有機体  | 生物／種 - ここではすべてのデータはマウスに由来する              |
| 年齢   | マウスの年齢（ここではすべてのマウスが8週齢であった）              |
| セックス | マウスの性別                                   |
| 感染症  | マウスの感染状態、すなわちA型インフルエンザに感染しているか、感染していないか。 |
| 緊張   | インフルエンザA型。                               |
| 時間   | 感染期間（日単位）。                               |
| 組織   | 遺伝子発現実験に使用した組織、すなわち小脳または脊髄。              |
| マウス  | マウス固有の識別子。                               |

R関数の`download.file()`を使って遺伝子発現データを含む
CSVファイルをダウンロードし、
`read.csv()` を使ってCSVファイルの内容を
`data.frame`クラスのオブジェクトとしてメモリにロードする。  download.file`コマンドの内部では、
の最初のエントリーは、ソースURLの文字列である。 このソースURL
はGitHubリポジトリからCSVファイルをダウンロードします。 
、カンマ（`"data/rnaseq.csv"`）の後のテキストは、
、ローカルマシン上のファイルの保存先です。 あなたのマシンに
`"data"`というフォルダを用意し、そこにファイルをダウンロードする必要があります。 そこで、このコマンドは
リモートファイルをダウンロードし、`"rnaseq.csv"` という名前を付けて、`"data"\` という名前の
フォルダに追加する。

```{r, eval=TRUE}
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv")
```

これでデータをロードする準備ができた：

```{r, eval=TRUE, purl=TRUE}
rna <- read.csv("data/rnaseq.csv")
```

、代入は何も表示しないからだ。
、データがロードされたことを確認したい場合は、
、その名前をタイプすることでデータフレームの中身を見ることができる：

```{r, eval=FALSE}
RNA
```

うわぁ...。 多くのアウトプットがあった。 少なくとも、
。 関数 `head()` を使って、このデータ・フレーム
の先頭（最初の6行）をチェックしてみよう：

```{r, purl=TRUE}
head(rna)
##
## View(rna)も試してみる。
```

**注**\*。

read.csv()`は、フィールドがカンマで区切られていると仮定しているが、
いくつかの国では、カンマは小数の区切り文字として使用され、
セミコロン（;）はフィールドの区切り文字として使用される。 Rでこの種のファイルを
、 `read.csv2()`関数を使うことができる。 
`read.csv()`と全く同じ動作をするが、
小数とフィールドのセパレーターに異なるパラメーターを使用する。 別の
フォーマットを使用している場合は、ユーザーが両方指定することができます。 詳しくは、
`read.csv()`のヘルプを`?read.csv`と入力して確認してください。 また、`read.delim()`関数があり、タブ区切りのデータファイルを読み込むことができる。 
重要なことは、これらの関数はすべて、
メインの`read.table()` 関数に異なる引数を指定するためのラッパー関数であるということです。  そのため、
上のデータは、`read.table()`、区切りの引数を`,\` にしてロードすることもできた。 コードは以下の通り：

```{r, eval=TRUE, purl=TRUE}
rna <- read.table(file = "data/rnaseq.csv",
                  sep = ",",
                  header = TRUE)
```

デフォルトでは `read.table()` の header 引数は
FALSE に設定されているので、
のヘッダーを読むためには header 引数を TRUE に設定しなければならない。

## データフレームとは？

データ・フレームは、ほとんどの表データ、
、統計やプロットに使われる_事実上の_データ構造である。

データフレームは手作業で作成することもできますが、最も一般的なのは、関数 `read.csv()` や `read.table()` によって生成される
データフレームです。

データフレームとは、
、列がすべて同じ長さのベクトルである表の形式でデータを表現したものである。
、列はベクトルであるため、各列は1種類のデータ
（文字、整数、因子など）を含まなければならない。 例えば、
、数値、文字、
論理ベクトルからなるデータフレームを示す図である。

![](./fig/data-frame.svg)

str()\`という関数で
：

```{r}
str(rna)
```

## data.frame\` オブジェクトの検査

関数 `head()` と `str()` が、
データフレームの内容と構造をチェックするのに便利であることは、すでに説明した。 以下は、
データの内容／構造を知るための、
非網羅的な機能のリストである。 試してみよう！

\*\*サイズ

- dim(rna)\` - 行数を最初の
  要素とし、列数を2番目の要素（オブジェクトの
  **dim**ensions ）とするベクトルを返す。
- nrow(rna)\` - 行の数を返す。
- ncol(rna)\` - 列数を返す。

\*\*内容

- head(rna)\` - 最初の6行を表示する。
- tail(rna)\` - 最後の6行を表示する。

**名前**：

- names(rna)`- 列名を返す（`data.frame`オブジェクトの`colnames()\` と同義）。
- rownames(rna)\` - 行の名前を返す。

**要約**：

- str(rna)\` - オブジェクトの構造と、
  クラス、各カラムの長さと内容に関する情報。
- `summary(rna)` - 各カラムの要約統計量。

注：これらの関数のほとんどは "ジェネリック "であり、`data.frame`以外の
オブジェクトにも使用できます。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジだ：

str(rna)\`の出力に基づいて、以下の
の質問に答えられるか？

- オブジェクト `rna` のクラスは何ですか？
- このオブジェクトにはいくつの行といくつの列がありますか？

:::::::::::::::  solution

## ソリューション

- クラス: データ・フレーム
- 行数：66465、列数：11：11

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## データフレームのインデックス化とサブセット化

rna\`データフレームには行と列がある（2次元ある）。
、そこから特定のデータを抽出したい場合は、
「座標」を指定する必要がある。 行番号が最初に来て、
列番号がそれに続く。 しかし、これらの
座標を指定する方法が異なれば、異なるクラスの結果が得られることに注意されたい。

```{r, eval=FALSE, purl=TRUE}
# データフレームの1列目の最初の要素（ベクトルとして）
rna[1, 1]
# 6列目の最初の要素（ベクトルとして）
rna[1, 6]
# データフレームの1列目の要素（ベクトルとして）
rna[, 1]
# データフレームの1列目の要素（data.フレームとして）
rna[1]
# 7列目の最初の3要素（ベクトルとして）
rna[1:3, 7]
# データフレームの3行目（data.frameとして）
rna[3, ]
# head_rna <- head(rna)
head_rna <- rna[1:6, ]
head_rna
```

1:10`と `10:1\`は
の例で、
の増加または減少の順序で整数の数値ベクトルを作成する特別な関数である。 詳しくは@ref(sec:genvec)を参照のこと。

また、「`-`」記号を使ってデータフレームの特定のインデックスを除外することもできる：

```{r, eval=FALSE, purl=TRUE}
rna[, -1] ## 最初の列を除いたデータフレーム全体
rna[-c(7:66465), ] ## head(rna)と等価
```

データフレームは、インデックス（前に示したように）や
、列名を直接呼び出してサブセットすることもできる：

```{r, eval=FALSE, purl=TRUE}
rna["gene"] # Result is a data.frame
rna[, "gene"] # Result is a vector
rna[["gene"]].     # 結果はベクトル
rna$gene          # 結果はベクトル
```

RStudio では、オートコンプリート機能を使用して、列の完全で
正しい名前を取得できます。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ

1. データセット `rna` の
   行 200 番目のデータのみを含む `data.frame` (`rna_200`) を作成する。

2. nrow()`が`data.frame\`の行数を示していることに気づいただろうか？

- この数字を使って、最初の
  `rna`データフレームの最後の行だけを取り出す。

- tail()\`を使った最後の行と比較し、
  、期待に応えていることを確認する。

- 行番号の代わりに `nrow()` を使って最後の行を取り出す。

- 最後の行から新しいデータフレーム（`rna_last`）を作成する。

3. `rna` データフレームの中央にある行を抽出するには `nrow()` を使用する。 この行の内容をオブジェクト
   `rna_middle` に格納する。

4. nrow()`と上記の `-` 表記を組み合わせると、rnaデータセットの1行目から6行目までの
     行だけを保持し、`head(rna)\`の
   挙動を再現することができる。

:::::::::::::::  solution

## ソリューション

```{r, purl=TRUE}
## 1.
rna_200 <- rna[200, ]
## 2.
## Saving `n_rows` to improve readability and reduce duplication
n_rows <- nrow(rna)
rna_last <- rna[n_rows, ]
## 3.
rna_middle <- rna[n_rows / 2, ]
## 4.
rna_head <- rna[-(7:n_rows), ]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## 要因

要因は**カテゴリーデータ**を表す。 これらは、
ラベルに関連付けられた整数として格納され、順序付けされたものであっても、順序付けされていないものであってもよい。
因子は文字ベクトルのように見える（そしてしばしば振舞う）が、
、実際にはRでは整数ベクトルとして扱われる。そのため、文字列として扱う場合は非常に
注意する必要がある。

いったん作成されたファクターは、あらかじめ定義された値のセット（
、_レベル_として知られている）しか含むことができない。 デフォルトでは、Rは常にレベルをアルファベット順（
）でソートする。 例えば、2つのレベルを持つ因子があるとする：

```{r, purl=TRUE}
セックス <- factor(c("male", "female", "female", "male", "female"))
```

Rは`1`をレベル`"female"`に、`2`をレベル
`"male"`に割り当てる（このベクトルの最初の要素
が`"male"`であるにもかかわらず、`f`が`m`の前に来るため）。 これは、
`levels()` という関数を使うことで見ることができ、`nlevels()` を使えばレベル数を知ることができる：

```{r, purl=TRUE}
levels(sex)
nlevels(sex)
```

要因の順番が重要でない場合もあるが、
、意味がある（例えば、"low"、
"medium"、"high"）、視覚化が向上する、または特定のタイプの分析で必要である（
）ため、順番を指定したい場合もある。 ここで、
`sex`ベクトルでレベルを並べ替える一つの方法は次のようになる：

```{r, purl=TRUE}
sex ## current order
sex <- factor(sex, levels = c("male", "female"))
sex ## after re-ordering
```

Rの記憶では、これらの因子は整数(1, 2, 3)、
で表現されるが、因子は自己
を記述するため、整数よりも情報量が多い。`"女性"`、`"男性"`は`1`、
`2`よりも説明的である。 どちらが "男性 "ですか？\
の整数データだけではわからないだろう。 一方、ファクターはこの情報を内蔵している。
特に、レベルが多い場合（例のデータセットの
遺伝子バイオタイプのような）に便利である。

データが因子として格納されているとき、各因子レベルによって表現されるオブザベーションの数
を素早く見るために、 `plot()`
関数を使うことができます。 データ中の男性
、女性の数を見てみよう。

```{r firstfactorplot, fig.cap="Bar plot of the number of females and males.", purl=TRUE}
プロット(性)
```

### 文字への変換

因数を文字ベクトルに変換する必要がある場合は、
`as.character(x)`.

```{r, purl=TRUE}
as.character(性)
```

<!-- ### Numeric factors -->

<!-- Converting factors where the levels appear as numbers (such as -->

<!-- concentration levels, or years) to a numeric vector is a little -->

<!-- trickier. The `as.numeric()` function returns the index values of the -->

<!-- factor, not its levels, so it will result in an entirely new (and -->

<!-- unwanted in this case) set of numbers.  One method to avoid this is to -->

<!-- convert factors to characters, and then to numbers.  Another method is -->

<!-- to use the `levels()` function. Compare: -->

<!-- ```{r} -->

<!-- year_fct <- factor(c(1990, 1983, 1977, 1998, 1990)) -->

<!-- as.numeric(year_fct)  ## Wrong! And there is no warning... -->

<!-- as.numeric(as.character(year_fct)) ## Works... -->

<!-- as.numeric(levels(year_fct))[year_fct] ## The recommended way. -->

<!-- ```

<!-- Notice that in the `levels()` approach, three important steps occur: -->

<!-- * We obtain all the factor levels using `levels(year_fct)` -->

<!-- * We convert these levels to numeric values using `as.numeric(levels(year_fct))` -->

<!-- * We then access these numeric values using the underlying integers of the -->

<!--   vector `year_fct` inside the square brackets -->

### 要因の名称変更

これらのファクターの名前を変えたい場合は、
：

```{r, purl=TRUE}
levels(sex)
levels(sex) <- c("M", "F")
sex
plot(sex)
```

::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジだ：

- F "と "M "の名前をそれぞれ "Female "と "Male "に変更する。

:::::::::::::::  solution

## ソリューション

```{r, eval=TRUE, purl=TRUE}
levels(sex)
levels(sex) <- c("Male", "Female")
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジだ：

read.csv()`を使ってデータフレームを作成する方法を見てきましたが、
`data.frame()`関数を使って手作業で作成することもできます。
この手作りの`data.frame\`にはいくつか間違いがある。
、それを見つけて修正することはできますか？  実験することをためらってはいけない！

```{r, eval=FALSE}
animal_data <- data.frame(
       animal = c(dog, cat, sea cucumber, sea nurchin),
       feel = c("furry", "squishy", "spiny"),
       weight = c(45, 8 1.1, 0.8))
```

:::::::::::::::  solution

## ソリューション

- 動物の名前の周りに引用符がない
- "feel "欄に1つ記入がない（おそらく毛皮の動物の1つ）。
- 体重欄のコンマが1つ足りない

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジだ：

次の
の例で、各列のクラスを予測できますか？

str(country_climate)\`を使って推測をチェックする：

- 期待通りですか？  なぜですか？ なぜだ？

- データフレームを作成する際に、最後の
  変数の後に `stringsAsFactors = TRUE` を追加してもう一度試してみてください。 今、何が起きているのか？
  stringsAsFactors`は、`read.csv()\`を使ってテキストベースの
  のスプレッドシートをRに読み込むときにも設定できる。

```{r, eval=FALSE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "South Africa", "Australia"),
       climate = c("cold", "hot", "temperate", "hot/temperate")、
       temperature = c(10, 30, 18, "15"),
       northern_hemisphere = c(TRUE, TRUE, FALSE, "FALSE"),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
)
```

:::::::::::::::  solution

## ソリューション

```{r, eval=TRUE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "South Africa", "Australia"),
       climate = c("cold", "hot", "temperate", "hot/temperate"),
       temperature = c(10, 30, 18, "15"),
       northern_hemisphere = c(TRUE, TRUE, FALSE, "FALSE"),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
       )
str(country_climate)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

データ型の自動変換は、時に恵みであり、時に
迷惑である。 その存在を認識し、ルールを学び、Rでインポートするデータ
がデータフレーム内で正しい型であることを再確認すること。 そうでない場合は、
データ入力中に生じたかもしれないミス（例えば、数字しか入っていないはずの列に文字が入っている）を検出するために、
を活用する。

詳しくはRStudio
チュートリアルをご覧ください。

## マトリックス

先に進む前に、データ・フレームについて学んだので、
パッケージのインストールを復習し、新しいデータ型、すなわち
`matrix` について学んでみよう。 data.frame`のように、行列は行と
列の2つの次元を持つ。 しかし大きな違いは、`行列`のすべてのセルは
同じ型でなければならないということである：numeric`、`character`、`logical`、...
その点で、行列は `data.frame` よりも `vector` に近い。

行列のデフォルトコンストラクタは `matrix` である。 行列を構成するための
の値のベクトルと、行および/または
の列数[^ncol]を取る。 下の図（
）のように、値は列に沿ってソートされる。

```{r mat1, purl=TRUE}
m <- matrix(1:9, ncol = 3, nrow = 3)
m
```

[^ncol]: 行数か列数のどちらかだけで十分で、もう一方は値の長さから推測できる。 値と行／列の数が合わない場合に何が起こるか試してみてください。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジだ：

installed.packages()`という関数を使って、
あなたのコンピューターに現在インストールされているすべてのパッケージの情報を含む `文字\`行列
を作成します。 探検してみよう。

:::::::::::::::  solution

## 解決策

```{r pkg_sln, eval=FALSE, purl=TRUE}
##
ip <- installed.packages()
head(ip)
## View(ip)
## パッケージの数
nrow(ip)
## インストールされている全てのパッケージの名前
rownames(ip)
## 各パッケージに関する情報の種類
colnames(ip)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

テストデータとして、大規模なランダムデータ行列を作成することはしばしば有用である。 以下の練習問題は、平均0、標準偏差
1の正規分布から無作為に
データを抽出して、そのような行列を作成するものです。これは `rnorm()` 関数で行うことができます。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジだ：

正規分布データ
（平均0、標準偏差1）の次元1000×3の行列を作る。

:::::::::::::::  solution

## ソリューション

```{r rnormmat_sln, purl=TRUE}
set.seed(123)
m <- matrix(rnorm(3000), ncol = 3)
dim(m)
head(m)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## 日付の書式設定

新人（そしてベテラン！）が抱える最も一般的な問題の1つである。 Rユーザーは、
、日付と時刻の情報を、
適切で分析中に使用可能な変数に変換している。

### 表計算ソフトの日付に関する注意

スプレッドシートの日付は通常、1つの列に格納される。
これが日付を記録する最も自然な方法のように思えるが、実際には
ベストプラクティスではない。 スプレッドシート・アプリケーションは、
一見正しい方法で日付を表示する（人間の観察者には）。しかし、実際に
どのように日付を処理し、保存するかには問題があるかもしれない。 YEAR、MONTH、DAYを別々のカラムに、または
、YEARとDAY-OF-YEARを別々のカラムに保存した方が、
より安全な場合が多い。

LibreOffice、Microsoft Excel、OpenOffice、
Gnumericなどの表計算プログラム。 は、
日付のエンコード方法が異なる（そしてしばしば互換性がない）（同じプログラムであっても、バージョンやオペレーティング
システム間で）。 さらに、エクセルは日付でないものを
日付に変える
(@Zeeberg:2004)ことができる。例えば、MAR1、DEC1、
OCT4のような名前や識別子である。 そのため、全体的に日付フォーマットを避けているのであれば、
、こうした問題を特定しやすくなる。

Data CarpentryレッスンのDates as
data
セクションでは、スプレッドシートを使った日付の落とし穴について、さらなる洞察
を提供しています。

**lubridate`** パッケージの `ymd()` 関数を使用します (**tidyverse`** に属します。詳しくは
[こちら](https://www.tidyverse.org/))。 . \*\*lubridate`**は**tidyverse`\*\*のインストールの一部として
。
**`tidyverse`** (`library(tidyverse)`) をロードすると、コアパッケージ (ほとんどのデータ分析で使用される
パッケージ) がロードされます。 **`lubridate`**
しかし、コアTidyverseには属さないので、
`library(lubridate)`で明示的にロードする必要があります。

必要なパッケージをロードすることから始める：

```{r loadlibridate, message=FALSE, purl=TRUE}
library("lubridate")
```

ymd()`は年、月、日を表すベクトルを受け取り、
`Date`ベクトルに変換する。 Date`はRが
、日付であると認識するデータのクラスであり、そのように操作することができる。
関数が必要とする引数は柔軟であるが、ベストプラクティスとしては、"YYYY-MM-DD "としてフォーマットされた文字
ベクトルである。

日付オブジェクトを作成し、構造を調べてみよう：

```{r, purl=TRUE}
my_date <- ymd("2015-01-01")
str(my_date)
```

では、年、月、日を別々に貼り付けてみよう：

```{r, purl=TRUE}
# sep は各コンポーネントを区切るために使う文字を示す
my_date <- ymd(paste("2015", "1", "1", sep = "-"))
str(my_date)
```

それでは、典型的な日付操作
のパイプラインに慣れておこう。 以下の小さなデータには、異なる `year`、
`month`、`day` 列に日付が格納されている。

```{r, purl=TRUE}
x <- data.frame(year = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),
                month = c(2, 3, 10, 1, 8, 3, 4, 5, 5),
                day = c(24, 8, 1, 5, 8, 17, 13, 10, 11, 24),
                value = c(4, 5, 1, 9, 3, 8, 10, 2, 6, 7))
x
```

次に、この関数を `x` データセットに適用する。 まず、`paste()` を使って、`x`
の `year`、`month`、`day` 列から
の文字ベクトルを作る：

```{r, purl=TRUE}
paste(x$year, x$month, x$day, sep = "-")
```

この文字ベクトルは `ymd()` の引数として使うことができる：

```{r, purl=TRUE}
ymd(paste(x$year, x$month, x$day, sep = "-"))
```

出来上がった `Date` ベクトルは `x` に `date` という新しいカラムとして追加することができる：

```{r, purl=TRUE}
x$date <- ymd(paste(x$year, x$month, x$day, sep = "-"))
str(x) # '日付'をクラスとする新しいカラムに注目。
```

すべてが正しく機能していることを確認しよう。
新しいカラムを検査する一つの方法は、`summary()`を使うことである：

```{r, purl=TRUE}
summary(x$date)
```

ymd()`は、年、月、日を
の順番で持つことを期待している。 例えば、日、月、年があれば、
`dmy()\` が必要になる。

```{r, purl=TRUE}
dmy(paste(x$day, x$month, x$year, sep = "-"))
```

lubdridate\`は、あらゆる日付のバリエーションに対応する多くの関数を持っている。

## Rオブジェクトの概要

これまで、次元数（
）、格納できるデータの種類（
）が単一か複数かによって異なる、いくつかのタイプのRオブジェクトを見てきた：

- **vector\`**：1次元（長さがある）、1種類のデータ。
- **マトリックス\`**：2次元、単一データ型。
- **data.frame\`**：2次元、1列1型。

## リスト

まだ見ていないが、知っておくと便利なデータ型がリストだ。
、先ほどのまとめから続く：

- **`list`**: 1つの次元で、各項目は異なるデータ
  型にすることができる。

以下では、数値、文字、
行列、データフレーム、別のリストのベクトルを含むリストを作ってみよう：

```{r list0, purl=TRUE}
l <- list(1:10, ## numeric
          letters, ## character
          installed.packages(), ## a matrix
          cars, ## a data.frame
          list(1, 2, 3)) ## a list
length(l)
str(l)
```

リストのサブセットは `[]` を使って新しいサブリストをサブセットするか、`[]]`
を使ってそのリストの単一要素を取り出す（
リストに名前がついている場合は、インデックスか名前を使う）。

```{r, purl=TRUE}
l[[1]]##
l[1:2] ## 長さ 2 のリスト
l[1] ## 長さ 1 のリスト
```

## 表形式データのエクスポートと保存 {#sec:exportandsave}

`read.table` ファミリーの関数を使って、テキストベースのスプレッドシートをRに読み込む方法を見てきた。 data.frame`を
テキストベースのスプレッドシートにエクスポートするには、
関数の `write.table` セット（`write.csv`, `write.delim`, ...）を使用します。 これらはすべて、
エクスポートする変数と、エクスポートするファイルを指定する。 例えば、
`rna`のデータを`data_output`ディレクトリの`my_rna.csv\` ファイルにエクスポートするには、次のように実行する：

```{r, eval=FALSE, purl=TRUE}
write.csv(rna, file = "data_output/my_rna.csv")
```

この新しいcsvファイルは、
、Rに精通していない他の共同研究者と共有することができます。`data.frame`のフィールドの一部（例えば、"product "列を参照）にカンマがあるにもかかわらず、Rはデフォルトで
、各フィールドを引用符で囲みます。したがって、
、列の区切り文字としてカンマを使用しているにもかかわらず、
、Rに正しく読み込むことができます。

:::::::::::::::::::::::::::::::::::::::: keypoints

- Rでの表形式データ

::::::::::::::::::::::::::::::::::::::::::::::::::
