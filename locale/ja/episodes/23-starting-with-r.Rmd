---
source: Rmd
title: R の紹介
teaching: 60
exercises: 60
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- R に関連する次の用語を定義します: オブジェクト、代入、呼び出し、関数、引数、オプション。
- R のオブジェクトに値を割り当てます。
- オブジェクトに _名前を付ける_方法を学ぶ
- コメントを使用してスクリプトに情報を与えます。
- R で単純な算術演算を解きます。
- 関数を呼び出し、引数を使用してデフォルトのオプションを変更します。
- ベクトルの内容を検査し、その内容を操作します。
- ベクトルから値をサブセット化して抽出します。
- データが欠落しているベクトルを解析します。

::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- R の最初のコマンド

::::::::::::::::::::::::::::::::::::::::::::::

> This episode is based on the Data Carpentries's _Data Analysis and
> Visualisation in R for Ecologists_ lesson.

## R でオブジェクトを作成する

コンソールに math と入力するだけで、R から出力を取得できます。

```{r, purl=TRUE}
3 + 5
12 / 7
```

ただし、便利で興味深いことを行うには、_値_を
_オブジェクト_ に割り当てる必要があります。 オブジェクトを作成するには、オブジェクトに名前を付け、その後に
代入演算子 `<-` と、それに付けたい値を付ける必要があります。

```{r, purl=TRUE}
weight_kg <- 55
```

`<-` は代入演算子です。 右側の値を左側の
個のオブジェクトに割り当てます。 したがって、「x <- 3」を実行すると、「x」の値は
`3` になります。 矢印は 3 **が `x` に入る** と読むことができます。  歴史的
理由により、代入に `=` を使用することもできますが、
のコンテキストで使用できるわけではありません。 構文に
わずかな違い](https://blog.revolutionanalytics.com/2008/12/use-equals-or-arrow-for-assignment.html)
があるため、常に `< を使用することをお勧めします。 -` 割り当て用。

RStudio では、 <kbd>オプション</kbd> を入力しながら、 <kbd>Alt</kbd> + <kbd>\-</kbd> を入力すると ( <kbd>\-</kbd> キーと同時に <kbd>Alt</kbd>
を押すと)、PC で
1 回のキーストロークで `<-` が書き込まれます。 + <kbd>\-</kbd> ( <kbd>オプション</kbd> <kbd>\-</kbd> キーと同時に押す) は、Mac でも
と同じことを行います。

### 変数に名前を付ける

オブジェクトには、「x」、「current_temperature」、または「subject_id」などの任意
名前を付けることができます。 オブジェクト名は明示的で、長
ないようにしたいと考えています。 数字で始めることはできません (「2x」は無効ですが、「x2」
は有効です)。 R では大文字と小文字が区別されます (たとえば、`weight_kg` は
の `Weight_kg` とは異なります)。 R の基本的な関数の名前であるため、使用でき
名前が
かあります (例: `if`、`else`、
`for`。2 [こちら](https://stat.ethz.ch)を参照)完全なリストについては、/R-manual/R-devel/library/base/html/Reserved.html)
)。 一般に、たとえ許可されていても、他の関数名 (例: `c`、`T`、`mean`、`data`、`df`、
`weights`) は使用しないことが
です。 疑問がある場合は、ヘルプを参照して、その名前がすでに
で使用されているかどうかを確認してください。 また
`my.dataset` のように、オブジェクト名内にドット (`.`) を使用しないことも最善です。 R には歴史的な理由から名前にドットが含まれる関数が多数あります
が、R
(メソッド) や他のプログラミング言語ではドットが特別な意味を持っているため、ドットは避けるのが最善です
。 オブジェクト名には名詞を使用し、関数名には動詞
を使用することもお勧めします。
のスタイル (スペースを入れる場所、オブジェクトの名前など) に一貫性を持たせることが重要です。
コーディング スタイルを使用すると、
の自分や共同作業者にとって、コードがより明確に読みやすくなります。 R では、人気のあるスタイル ガイド
には、[Google の](https://google.github.io/styleguide/Rguide.xml)、
[tidyverse の](https://style.tidyverse.org/) スタイル、およびBioconductor
スタイル
ガイド。
Tidyverse は非常に包括的であり、最初は
では圧倒されるように思えるかもしれません。
[**`lintr`**](https://github.com/jimhester/lintr) パッケージを
にインストールすると、コードのスタイルの問題が自動的にチェックされます。

> **オブジェクトと変数**: 「R」で「オブジェクト」として知られているものは、他の多くのプログラミング言語では「変数」として知られて
> ます。
> に応じて、「オブジェクト」と「変数」は
> に異なる意味を持つ可能性があります。 ただし、このレッスンでは、2 つの単語は
> 的に使用されます。 詳細については、
> [ここを参照してください。](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects)

オブジェクトに値を割り当てるとき、R は何も出力しません。 かっこを使用するか
名を入力することで、
に値を強制的に出力させることができます。

```{r, purl=TRUE}
weight_kg <- 55    # 何も出力しません
(weight_kg <- 55)  #  しかし、呼び出しを括弧で囲むと `weight_kg` の値が出力され、
weight_kg          # オブジェクトの名前を入力しても同様に出力されます
```

R のメモリに「weight_kg」があるので、それを使って算術演算を行うことができます。
、この重量をポンドに変換したい場合があります (ポンドでの重量は kg での重量の 2.2 倍です)。

```{r, purl=TRUE}
2.2 * weight_kg
```

オブジェクトに新しい値を割り当てることで、オブジェクトの値を変更することもできます。

```{r, purl=TRUE}
weight_kg <- 57.5
2.2 * weight_kg
```

これは、
つのオブジェクトに値を割り当てても、他のオブジェクトの値は変更されないことを意味します。たとえば、動物の体重をポンド単位で新しい
オブジェクト `weight_lb` に保存してみましょう。

```{r, purl=TRUE}
weight_lb <- 2.2 * weight_kg
```

次に「weight_kg」を 100 に変更します。

```{r}
weight_kg <- 100
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

オブジェクト「weight_lb」の現在の内容は何だと思いますか?
126\.5 それとも 220?

::::::::::::::::::::::::::::::::::::::::::::::

## コメント

のコメント文字は `#` です。0 スクリプトの `#` の右側にあるものはすべて R によって無視されます。スクリプトにメモ
説明を残すと便利です。

RStudio では、段落のコメントまたはコメント解除が簡単に行えます。
コメントしたい行を選択した後、
キーボード <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>を同時に押します。
の場合、1 行だけをコメントアウトしたい場合は、その行の任意
位置にカーソルを置きます (つまり、行全体を選択する必要はありません)。その後
Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><kbd>押します。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ

次の各ステートメントの後の値は何ですか?

```{r, purl=TRUE}
mass <- 47.5            # 質量?
age  <- 122             # 年齢?
mass <- mass * 2.0      # 質量?
age  <- age - 20        # 年齢?
mass_index <- mass/age  # 質量指数?
```

::::::::::::::::::::::::::::::::::::::::::::::

## 関数とその引数

関数は、操作の割り当て
を含む、より複雑なコマンド セットを自動化する「定型スクリプト」です。 多くの関数は事前定義されているか、R _パッケージ_ をインポートすることで
可能になります (詳細は後ほど)。 関数
は通常、_arguments_ と呼ばれる 1 つ以上の入力を取得します。 関数は多くの場合 (常に
ではありませんが) _値_ を返します。 典型的な例は関数 `sqrt()` です。
入力 (引数) は数値でなければならず、戻り値 (実際には
出力) はその数値の平方根です。 関数の実行 (「実行中」)
は関数の _呼び出し_ と呼ばれます。 関数呼び出しの例は次のとおりです。

```{r, eval=FALSE, purl=FALSE}
b <- sqrt(a)
```

ここでは、`a` の値が `sqrt()` 関数に与えられ、`sqrt()` 関数は
平方根を計算し、その値をオブジェクト \`
に代入して返します。 この関数は引数を 1 つだけ取るため、非常に単純です。

関数の戻り値「値」は数値 (`sqrt()` のような) である必要はなく、
である必要もありません。また、単一の項目である必要もありません。一連のものや
、さらにはデータセットでも構いません。 データ ファイルを R に読み込むと、それがわかります。

引数には、数値やファイル名だけでなく、他の
も含めることができます。 各引数の正確な意味は関数ごとに異なるため、ドキュメントで調べて
にする必要があります (下記を参照)。 一部の関数は引数を取ります
はユーザーによって指定されるか、指定されなかった場合は _デフォルト_ 値を取ります:
これらは _オプション_ と呼ばれます。 オプションは通常、「不正な値」を無視するかどうか、プロットでどのような記号を使用
かなど、
関数の動作方法を変更するために使用されます。  ただし、特定の値が必要な場合は、デフォルトの代わりに使用される値
を選択して指定できます。

複数の引数を取ることができる関数 `round()` を試してみましょう。

```{r, results="show", purl=TRUE}
round(3.14159)
```

ここでは、1 つの引数 `3.14159` を指定して `round()` を呼び出しましたが、
が値 `3` を返しました。  これは、デフォルトでは最も近い
整数に丸められるためです。 さらに多くの桁が必要な場合は、「round」関数に関する
情報を取得することでその方法がわかります。  `args(round)` を使用するか、`?round` を使用して
関数のヘルプを参照することができます。

```{r, results="show", purl=TRUE}
args(round)
```

```{r, eval=FALSE, purl=TRUE}
?round
```

別の桁数が必要な場合は、`digits=2` または必要な桁数を入力
ことがわかります。

```{r, results="show", purl=TRUE}
round(3.14159, digits = 2)
```

定義されているのとまったく同じ順序で引数を指定する場合は
に名前を付ける必要はありません。

```{r, results="show", purl=TRUE}
round(3.14159, 2)
```

引数に名前を付けた場合は、その順序を入れ替えることができます。

```{r, results="show", purl=TRUE}
round(digits = 2, x = 3.14159)
```

関数呼び出しの最初にオプションではない引数 (
四捨五入する数値など) を置き、すべてのオプションの
引数の名前を指定することをお勧めします。  そうしないと、コードを読む人が、
をしているのかを理解するために、なじみのない引数を持つ関数の定義を調べなければなら
可能性があります。 引数の名前を指定することで、関数インターフェースの将来の変更 (既存の引数の間に
引数が追加される可能性) から
することもできます。

## ベクトルとデータ型

ベクトルは R で最も一般的かつ基本的なデータ型であり、ほぼ R の主力である
です。ベクトルは、
数字や文字などの一連の値で構成されます。
の `c()` 関数を使用して、一連の値をベクトルに割り当てることができます。 たとえば、動物の体重のベクトルを作成し、それを新しいオブジェクト `weight_g` に
に割り当てることができます。

```{r, purl=TRUE}
weight_g <- c(50, 60, 65, 82)
weight_g
```

ベクトルには文字も含めることができます。

```{r, purl=TRUE}
molecules <- c("dna", "rna", "protein")
molecules
```

ここでは「dna」や「rna」などの引用符が重要です。 引用符
がないと、R は `dna`、`rna`、および
`protein` と呼ばれるオブジェクトがあると想定します。 これらのオブジェクトは R のメモリに存在しないため、エラー メッセージが
されます。

ベクトルの内容を検査できる関数が多数あります。 `length()` は、特定のベクトルに含まれる要素の数を示します。

```{r, purl=TRUE}
length(weight_g)
length(molecules)
```

ベクトルの重要な特徴は、すべての要素が
タイプのデータであることです。  関数 `class()` は、オブジェクトのクラス (
型の要素) を示します。

```{r, purl=TRUE}
class(weight_g)
class(molecules)
```

関数 `str()` は、
オブジェクトとその要素の構造の概要を提供します。 これは、
て複雑なオブジェクトを扱う場合に便利な関数です。

```{r, purl=TRUE}
str(weight_g)
str(molecules)
```

`c()` 関数を使用して、ベクトルに他の要素を追加できます。

```{r}
weight_g <- c(weight_g, 90) # ベクトルの最後に追加
weight_g <- c(30, weight_g) # ベクトルの先頭に追加
weight_g
```

最初の行では、元のベクトル `weight_g` を取得し、その末尾に
値 `90` を追加し、結果を
`weight_g` に保存します。 次に、値 `30` を先頭に追加し、結果を再び
として `weight_g` に保存します。

これを何度も繰り返してベクトルを成長させたり、
データセットを組み立てたりすることができます。  これは、プログラムするときに、
または計算している結果を追加するのに役立つ場合があります。

**アトミック ベクトル**は最も単純な R **データ型**であり、単一型の線形
ベクトルです。 上では、R が使用する 6 つの主な **アトミック
ベクトル** タイプのうち 2 つ、つまり `"character"` と `"numeric"` (または
`"double"`) を見てきました。 これらは、すべての R オブジェクト
が構築される基本的な構成要素です。 他の 4 つの **原子ベクトル** タイプは次のとおりです。

- `TRUE` および `FALSE` の場合は `"logical"` (ブール データ型)
- 整数の場合は `"integer"` (たとえば、`2L`、`L` は R
  にそれが整数であることを示します)
- `"complex"` は、実数と虚数の
  部分を持つ複素数を表します (例: 1 + 4i)。これについて説明するのはこれですべてです。
- ビットストリームの「raw」\` (これ以上は説明しません)

`typeof()` 関数
を使用し、ベクトルを引数として入力することで、ベクトルの型をチェックできます。

ベクトルは、R が使用する多くの **データ構造** の 1 つです。 その他
重要なものは、リスト (`list`)、行列 (`matrix`)、データ フレーム
(`data.frame`)、因子 (`factor`)、および配列 (`array`) です。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

アトミック ベクトルの型は、文字、数値 (または
double)、整数、および論理型であることがわかりました。 しかし、これらのタイプを
つのベクトルに混在させようとするとどうなるでしょうか?

:::::::::::::::  solution

## 解決

R はそれらをすべて同じ型に暗黙的に変換します。

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

これらのそれぞれの例では何が起こるでしょうか? (ヒント: `class()` を使用してオブジェクトのデータ型を確認
、名前を入力して何が起こるかを確認します):

```{r, eval=TRUE}
num_char <- c(1, 2, 3, "a")
num_logical <- c(1, 2, 3, TRUE, FALSE)
char_logical <- c("a", "b", "c", TRUE)
tricky <- c(1, 2, 3, "4")
```

:::::::::::::::  solution

## 解決

```{r, purl=TRUE}
class(num_char)
num_char
class(num_logical)
num_logical
class(char_logical)
char_logical
class(tricky)
tricky
```

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

なぜそれが起こると思いますか?

:::::::::::::::  solution

## 解決

ベクトルのデータ型は 1 つだけです。 R は、
が情報を失わないという _共通分母_ を見つけるために、このベクトルの内容を
に変換 (強制) しようとします。

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

次の例では、`combined_logical` 内の `"TRUE"` (文字として)
となる値はいくつありますか。

```{r, eval=TRUE}
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
combined_logical <- c(num_logical, char_logical)
```

:::::::::::::::  solution

## 解決

唯一。 過去のデータ型の記憶はなく、ベクトルが初めて評価されるときに強制
が発生します。 したがって、「num_logical」の「TRUE」
「combined_logical」で
「1」に変換される前に、「1」に変換されます。

```{r}
combined_logical
```

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

R では、オブジェクトをあるクラスから別のクラスに変換することを
強制\* と呼びます。 これらの変換は階層
に従って行われ、一部の型が優先的に他の型に強制されます。 これらのデータ
がどのように強制されるかの階層を表す図を描いてもらえます
?

:::::::::::::::  solution

## 解決

論理 → 数値 → 文字 ← 論理

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

```{r, echo=FALSE, eval=FALSE, purl=TRUE}
## アトミックベクトルは文字型、数値型、整数型、
## 論理型があることを見てきました。しかし、これらの型を1つの
## ベクトルに混在させようとしたらどうなるでしょうか？

## それぞれの例で何が起こるか？(ヒント: `class()` を使って
## オブジェクトのデータ型をチェックしてみましょう)
num_char <- c(1, 2, 3, "a")

num_logical <- c(1, 2, 3, TRUE)

char_logical <- c("a", "b", "c", TRUE)

tricky <- c(1, 2, 3, "4")

## なぜそうなると思いますか?

##
## ベクトル内で、異なる型のオブジェクトが単一の共有型に変換されることにお気づきでしょう。Rでは、
## オブジェクトをあるクラスから別のクラスに変換することを
## _coercion_と呼んでいます。これらの変換は階層に従って行われ、
## ある型が優先的に他の型に強制されます。
## これらのデータ型がどのように強制されるのか、その階層を表す図を描けますか?
```

## ベクトルのサブセット化

ベクトルから 1 つまたは複数の値を抽出したい場合は、角括弧内に 1 つまたは複数のインデックスを指定する必要が
ます。 例えば：

```{r, results="show", purl=TRUE}
molecules <- c("dna", "rna", "peptide", "protein")
molecules[2]
molecules[c(3, 2)]
```

インデックスを繰り返して、元のオブジェクトよりも要素
が多いオブジェクトを作成することもできます。

```{r, results="show", purl=TRUE}
more_molecules <- molecules[c(1, 2, 3, 2, 1, 4)]
more_molecules
```

R インデックスは 1 から始まります。 Fortran、MATLAB、
Julia、R などのプログラミング言語は
から数え始めます。これは人間が通常行うことだからです。 C ファミリの言語 (C++、Java、Perl、
、Python を含む) は 0 からカウントします。これは、コンピュータにとってその方が簡単なためです。

最後に、負のインデックスを使用して、指定された一部の要素を除くベクトル
のすべての要素を取得することもできます。

```{r}
分子 ## すべての分子
分子[-1] ## 最初の分子を除くすべての分子
分子[-c(1, 3)] ## 1 番目/3 番目の分子を除くすべての分子
分子[c(-1, -3)] # # 1番目/3番目を除くすべて
```

## 条件付きサブセット化

サブセット化のもう 1 つの一般的な方法は、論理ベクトルを使用することです。 `TRUE` は同じインデックスを持つ要素を選択し
が、`FALSE` は選択しません。

```{r, purl=TRUE}
weight_g <- c(21, 34, 39, 54, 55)
weight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]
```

通常、これらの論理ベクトルは手動で入力されるのではなく、他の関数または論理テストの
出力です。 たとえば、50 を超える値のみを選択したい場合は、
のようにします。

```{r, purl=TRUE}
## will return logicals with TRUE for the indices that meet
## the condition
weight_g > 50
## so we can use this to select only the values above 50
weight_g[weight_g > 50]
```

`&` (両方の条件が true、
AND) または `|` (少なくとも 1 つの条件が true、OR) を使用して複数のテストを結合できます。

```{r, results="show", purl=TRUE}
weight_g[weight_g < 30 | weight_g > 50]
weight_g[weight_g >= 30 & weight_g == 21]
```

ここで、「<」は「より小さい」、「>」は「より大きい」、「>=」は
「以上」、「==」は「等しい」を表します。 2 つの等号
記号「==」は、左側と
の数値が等しいかどうかをテストするものであり、(「<-」と同様に) 変数の代入を
する単一の `=` 記号と混同しないでください。 。

一般的なタスクは、ベクトル内の特定の文字列を検索することです。\
「or」演算子 `|` を使用して複数の値が等しいかどうかをテストすることもできますが、
これはすぐに面倒になります。 関数 `%in%` を使用すると、検索ベクトルの要素が見つかったかどうかを
できます。

```{r, purl=TRUE}
分子 <- c("dna", "rna", "タンパク質", "ペプチド")
分子[分子 == "rna" |分子 == "dna"] # rna と dna の両方を返します
分子 %in% c("rna", "dna", "代謝物", "ペプチド", "グリセロール")
分子[分子 %in% c("rna", " 「DNA」、「代謝物」、「ペプチド」、「グリセロール」)]
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

なぜ `"four" > "five"` が `TRUE` を返すのか理解できますか?

:::::::::::::::  solution

## 解決

```{r}
"four" > "five"
```

文字列で `>` または `<` を使用すると、R はそれらのアルファベット順を比較します。
ここで、`"four"` は `"five"` の後に来るので、それは \*
より大きい\* です。

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

## 名前

ベクトルの各要素に名前を付けることができます。
より下のコード チャンクは、名前のない初期ベクトル、名前の設定方法、および
取得される様子を示しています。

```{r}
x <- c(1, 5, 3, 5, 10)
names(x) ## 名前なし
names(x) <- c("A", "B", "C", "D", " E")
名前(x) ## これで名前が決まりました
```

ベクトルに名前がある場合、
に加えて名前によって要素にアクセスすることができます。

```{r}
x[c(1, 3)]
x[c("A", "C")]
```

## データが欠落しています

R はデータセットを分析するように設計されているため、欠損データが
であるという概念が含まれています (これは
のプログラミング言語では一般的ではありません)。 欠損データはベクトルで「NA」として表されます。

数値の演算を行う場合、扱っているデータに欠損値が含まれている場合
ほとんどの関数は「NA」を返します。 この機能により、
データを処理し
いるケースを見逃しにくくなります。  引数 `na.rm = TRUE` を追加すると、欠損値を無視して結果を
として計算できます。

```{r}
heights <- c(2, 4, 4, NA, 6)
mean(heights)
max(heights)
mean(heights, na.rm = TRUE)
max(heights, na.rm = TRUE)
```

データに欠損値が含まれている場合は、関数 `is.na()`、`na.omit()`、および `complete.cases()` に
ておくとよいでしょう。 例については、以下の
を参照してください。

```{r}
## 欠損値のない要素を抽出します。
heights[!is.na(heights)]

## 不完全なケースを削除したオブジェクトを返します。
## 返されるオブジェクトは、タイプ `"numeric"` の原子ベクトルです。
## (または `"double"`)。
na.omit(heights)

## 完全なケースである要素を抽出します。
## 返されるオブジェクトは、タイプ `"numeric"` の原子ベクトルです。
## (または `"double"`)。
の高さ[完全なケース(高さ)]
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

1. このインチ単位の高さのベクトルを使用して、NA を削除した新しいベクトルを作成します。

```{r}
高さ <- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)
```

2. 関数 `median()` を使用して、`heights` ベクトルの中央値を計算します。
3. R を使用して、セット内の身長が 67 インチを超える人が何人いるかを計算します。

:::::::::::::::  solution

## 解決

```{r, purl=TRUE}
heights_no_na <- heights[!is.na(heights)]
## または
heights_no_na <- na.omit(heights)
```

```{r, purl=TRUE}
median(heights, na.rm = TRUE)
```

```{r, purl=TRUE}
height_above_67 <- height_no_na[heights_no_na > 67]
長さ(heights_above_67)
```

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

## ベクトル {#sec:genvec}の生成

```{r, echo=FALSE}
set.seed(1)
```

### コンストラクター

異なるタイプのベクトルを生成する関数がいくつか存在します。 数値のベクトルを生成
には、`numeric()`
コンストラクターを使用し、出力ベクトルの長さを
パラメーターとして指定します。 値は 0 で初期化されます。

```{r, purl=TRUE}
数値(3)
数値(10)
```

長さ 0 の数値ベクトルを要求すると、次のように
が得られることに注意してください。

```{r, purl=TRUE}
数値(0)
```

文字と論理に対しても同様のコンストラクターがあり、
`character()` と `logical()` という名前が付けられます。

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

文字ベクトルと論理ベクトルのデフォルトは何ですか?

:::::::::::::::  solution

## 解決

```{r, purl=TRUE}
文字(2) ## 空の文字
論理的(2) ## FALSE
```

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

### 要素を複製する

`rep` 関数を使用すると、値を特定の回数 (
回) 繰り返すことができます。 たとえば、長さ 5 の数値ベクトルを
から値 -1 で開始したい場合は、次のようにすることができます。

```{r, purl=TRUE}
担当者(-1, 5)
```

同様に、収集されるデータ
に仮定を設定せずに、欠損値が入力されたベクトルを生成するには (多くの場合、
から始めるのが良い方法です):

```{r, purl=TRUE}
担当者(NA, 5)
```

`rep` は、入力として任意の長さのベクトル (上記では長さ 1 のベクトル
を使用しました) および任意のタイプを受け取ることができます。 たとえば、
値 1、2、3 を 5 回繰り返す場合は、次のようにします。

```{r, purl=TRUE}
rep(c(1, 2, 3), 5)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

値 1、2、3 を 5 回繰り返したいのに、
1 を 5 つ、2 を 5 つ、3 を 5 つこの順序で取得した場合はどうなるでしょうか。
可能性は 2 つあります。ヘルプについては `?rep` または `?sort` を参照してください。

:::::::::::::::  solution

## 解決

```{r, purl=TRUE}
rep(c(1, 2, 3), each = 5)
sort(rep(c(1, 2, 3), 5))
```

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::

### シーケンスの生成

もう 1 つの非常に便利な関数は、
の数値シーケンスを生成する `seq` です。 たとえば、1 から 20
までの整数のシーケンスを 2 ずつ生成するには、次のコマンドを使用します。

```{r, purl=TRUE}
seq(from = 1, to = 20, by = 2)
```

`by` のデフォルト値は 1 で、1 のステップで 1 つの値から別の値への
シーケンスの生成が頻繁に使用されることを考えると、
というショートカットがあります。

```{r, purl=TRUE}
seq(1, 5, 1)
seq(1, 5) ## default by
1:5
```

最終長さが
の 1 から 20 までの一連の数値を生成するには、次のコマンドを使用します。

```{r, purl=TRUE}
seq(from = 1, to = 20, length.out = 3)
```

### ランダムなサンプルと順列

有用な関数の最後のグループは、ランダムな
データを生成する関数です。 最初の `sample` は、
のベクトルのランダムな置換を生成します。 たとえば、口頭試験を行わない
人の生徒にランダムな順序を付けるには
まず各生徒に 1 から 10 までの番号を割り当てます (たとえば、名前のアルファベット順に基づきます)。次に次のようにします。

```{r, purl=TRUE}
sample(1:10)
```

さらなる引数がなければ、`sample` はベクトルのすべての
要素の順列を返します。 特定のサイズのランダムなサンプルが必要な場合、I
はこの値を 2 番目の引数として設定します。 以下では、事前定義された `letters` ベクトルに含まれるアルファベットから 5 つのランダムな
文字をサンプリングします。

```{r, purl=TRUE}
sample(letters, 5)
```

入力ベクトルよりも大きな出力が必要な場合、または一部の要素を複数回
できるようにしたい場合は、引数 `replace`
を `TRUE` に設定する必要があります。

```{r, purl=TRUE}
sample(1:5, 10, replace = TRUE)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ：

上記の関数を試してみると、
サンプルは実際にランダムであり、同じ
順列が 2 回発生することはないことがわかるでしょう。 これらのランダムな描画を再現できるようにするには、ランダム サンプルを描画する前に
`set.seed()` を使用
て乱数生成シードを手動で設定します。

近所の人と一緒にこの機能をテストしてください。 まず、「1:10」のランダムな
順列を 2 つ個別に描画し、
の異なる結果が得られることを観察します。

次に、たとえば `set.seed(123)` でシードを設定し、
ランダムな描画を繰り返します。 同じランダムな抽選が行われることに注目してください。

別のシードを設定して繰り返します。

:::::::::::::::  solution

## 解決

さまざまな順列

```{r, purl=TRUE}
sample(1:10)
sample(1:10)
```

シード 123 と同じ順列

```{r, purl=TRUE}
set.seed(123)
sample(1:10)
set.seed(123)
sample(1:10)
```

違う種

```{r, purl=TRUE}
set.seed(1)
sample(1:10)
set.seed(1)
sample(1:10)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

### 正規分布からサンプルを抽出する

最後に説明する関数は `rnorm` で、正規分布からランダムな
サンプルを抽出します。 平均
および 100、標準偏差 1 および 5 の 2 つの正規分布 (_N(0, 1)_ および
_N(100, 5)_ と表記) を以下に示します。

```{r, echo=FALSE, fig.width=12, fig.height=6, fig.cap="Two normal distributions: *N(0, 1)* on the left and *N(100, 5)* on the right."}
par(mfrow = c(1, 2))
plot(density(rnorm(1000)), main = "", sub = "N(0, 1)")
plot(density(rnorm(1000, 100, 5)), main = "", sub = "N(100, 5)")
```

3 つの引数「n」、「mean」、「sd」は、サンプル
のサイズと、正規分布のパラメーター、つまり平均
とその標準偏差を定義します。 後者のデフォルトは 0 と 1 です。

```{r, purl=TRUE}
rnorm(5)
rnorm(5, 2, 2)
rnorm(5, 100, 5)
```

スクリプトの書き方と
のデータ構造の基本を学習したので、より大きなデータの操作を開始する準備が整い、データ フレームについて
します。

:::::::::::::::::::::::::::::::::::::::: keypoints

- Rと対話する方法

::::::::::::::::::::::::::::::::::::::::::::::::::
