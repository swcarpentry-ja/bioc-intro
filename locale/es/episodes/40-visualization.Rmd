---
source: Rmd
title: Visualización de datos
teaching: 60
exercises: 60
---

```{r loaddata_vis, echo=FALSE, purl=FALSE, message=FALSE}
if (!file.exists("data/rnaseq.csv"))
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv")
```

::::::::::::::::::::::::::::::::::::::: objectives

- Produzca diagramas de dispersión, diagramas de caja, diagramas de líneas, etc. utilizando ggplot.
- Establezca configuraciones de trama universales.
- Describe qué es el facetado y aplícalo en ggplot.
- Modifique la estética de un gráfico ggplot existente (incluidas las etiquetas de los ejes y el color).
- Cree gráficos complejos y personalizados a partir de datos en un marco de datos.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: preguntas

- Visualización en R

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r vis_setup, echo=FALSE}
rna <- read.csv("data/rnaseq.csv")
```

> Este episodio se basa en la lección _Análisis de datos y
> Visualización en R para ecologistas_ de Data Carpentries.

## Visualización de datos

Comenzamos cargando los paquetes requeridos. **`ggplot2`** está incluido en
el paquete **`tidyverse`**.

```{r load-package, message=FALSE, purl=TRUE}
library("tidyverse")
```

Si aún no está en el espacio de trabajo, cargue los datos que guardamos en la lección
anterior.

```{r load-data, eval=FALSE, purl=TRUE}
rna <- read.csv("data/rnaseq.csv")
```

La Hoja de trucos de visualización de datos

cubrirá los conceptos básicos y las funciones más avanzadas de ` ggplot2` y
ayudará, además de servir como recordatorio, a obtener una descripción general de las
muchas representaciones de datos disponibles en el paquete. Los siguientes videos
tutoriales ([parte 1](https://www.youtube.com/watch?v=h29g21z0a68) y
[2](https://www.youtube.com /watch?v=0m4yywqNPVY)) de Thomas Lin Pedersen
también son muy instructivos.

## Trazar con `ggplot2`

`ggplot2` es un paquete de trazado que simplifica la creación de trazados
complejos a partir de datos en un marco de datos. Proporciona una interfaz
más programática para especificar qué variables trazar, cómo se muestran,
y propiedades visuales generales. El fundamento teórico que sustenta
el `ggplot2` es la _Gramática de Gráficos_ (@Wilkinson:2005). Usando este enfoque
, solo necesitamos cambios mínimos si los datos subyacentes cambian o
si decidimos cambiar de un diagrama de barras a un diagrama de dispersión. Esto ayuda a
a crear gráficos con calidad de publicación con una cantidad mínima de ajustes
y ajustes.

Hay un libro sobre `ggplot2` (@ggplot2book) que proporciona una buena
descripción general, pero está desactualizado. La tercera edición está en preparación y
estará [disponible gratuitamente en línea](https://ggplot2-book.org/). La página web `ggplot2`
([https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org)) proporciona amplia documentación.

`ggplot2` funciona como datos en formato 'largo', es decir, una columna para
cada dimensión y una fila para cada observación. Los datos bien estructurados
te ahorrarán mucho tiempo al hacer figuras con `ggplot2`.

Los gráficos de ggplot se crean paso a paso agregando nuevos elementos. Agregar
capas de esta manera permite una gran flexibilidad y
personalización de los gráficos.

> La idea detrás de la Gramática de Gráficos es que puedes construir cada gráfico
> a partir de los mismos 3 componentes: (1) un conjunto de datos, (2) un sistema de coordenadas,
> y (3) geoms. — es decir, marcas visuales que representan puntos de datos \[^tres\\_comp\\_ggplot2]

[^three_comp_ggplot2]: Fuente: [Hoja de referencia de visualización de datos](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf).

Para construir un ggplot, usaremos la siguiente plantilla básica que se puede
usar para diferentes tipos de gráficos:

```
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```

- use la función `ggplot()` y vincule el gráfico a un \*\*marco de datos
  \*\* específico usando el argumento `data`

```{r, eval=FALSE}
ggplot(data = rna)
```

- defina un **mapeo** (usando la función estética (`aes`)), seleccionando
  las variables que se trazarán y especificando cómo presentarlas
  en el gráfico, por ejemplo, como x/ y posiciones o características como
  tamaño, forma, color, etc.

```{r, eval=FALSE}
ggplot(data = rna, mapping = aes(x = expression))
```

- agregue '**geoms**': geometrías o representaciones gráficas de los datos
  en el gráfico (puntos, líneas, barras). `ggplot2` ofrece muchas
  geoms diferentes; Usaremos algunos comunes hoy, que incluyen:

  ```
  * `geom_point()` para diagramas de dispersión, diagramas de puntos, etc.
  * `geom_histogram()` para histogramas
  * `geom_boxplot()` para, bueno, diagramas de caja.
  * `geom_line()` para líneas de tendencia, series de tiempo, etc.
  ```

Para agregar una geometría (etry) al gráfico, use el operador `+`. Usemos
`geom_histogram()` primero:

```{r first-ggplot, cache=FALSE, purl=TRUE}
ggplot(data = rna, mapping = aes(x = expression)) +
  geom_histogram()
```

El `+` en el paquete `ggplot2` es particularmente útil porque
te permite modificar objetos `ggplot` existentes. Esto significa que puedes
configurar fácilmente plantillas de gráficos y explorar cómodamente diferentes tipos de gráficos
, por lo que el gráfico anterior también se puede generar con un código como este:

```{r, eval=FALSE, purl=TRUE}
# Asignar gráfico a una variable
rna_plot <- ggplot(data = rna,
                   mapping = aes(x = expression))

# Dibujar el gráfico
rna_plot + geom_histogram()
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Probablemente hayas notado un mensaje automático que aparece cuando
dibuja el histograma:

```{r, echo=FALSE, fig.show="hide"}
ggplot(rna, aes(x = expression)) +
  geom_histogram()
```

Cambie los argumentos `bins` o `binwidth` de `geom_histogram()` a
cambie el número o ancho de los bins.

:::::::::::::::  solution

## Solución

```{r, purl=TRUE}
# cambiar contenedores
ggplot(rna, aes(x = expresión)) +
    geom_histogram(bins = 15)

# cambiar ancho de contenedor
ggplot(rna, aes( x = expresión)) +
    geom_histogram(binwidth = 2000)
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Podemos observar aquí que los datos están sesgados hacia la derecha. Podemos aplicar la transformación
log2 para tener una distribución más simétrica. Tenga en cuenta que
agregamos aquí un pequeño valor constante (`+1`) para evitar que se devuelvan valores `-Inf`
para valores de expresión iguales a 0.

```{r log-transfo, cache=FALSE, purl=TRUE}
rna <- rna %>%
  mutar(expresión_log = log2(expresión + 1))
```

Si ahora dibujamos el histograma de las expresiones transformadas log2, la distribución
está más cerca de una distribución normal.

```{r second-ggplot, cache=FALSE, purl=TRUE}
ggplot(rna, aes(x = expresión_log)) + geom_histogram()
```

De ahora en adelante trabajaremos en los valores de expresión transformados logarítmicamente.

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Otra forma de visualizar esta transformación es considerar la escala
de las observaciones. Por ejemplo, puede que valga la pena cambiar la escala
del eje para distribuir mejor las observaciones en el espacio del gráfico
. Cambiar la escala de los ejes se realiza de manera similar a
agregar/modificar otros componentes (es decir, agregando incrementalmente comandos
). Intenta hacer esta modificación:

- Representa la expresión no transformada en la escala log10; ver
  `scale_x_log10()`. Compáralo con el gráfico anterior. ¿Por qué
  ahora aparecen mensajes de advertencia?

::::::::::::::: solución

## Solución

```{r, eval=TRUE, purl=TRUE, echo=TRUE}
ggplot(datos = rna,mapping = aes(x = expresión))+
  geom_histogram() +
  scale_x_log10()
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

**Notas**

- Todo lo que pongas en la función `ggplot()` puede ser visto por cualquier geom
  capas que agregues (es decir, estas son configuraciones de trazado globales). Este
  incluye el mapeo de los ejes x e y que configuró en `aes()`.
- También puede especificar asignaciones para una geom determinada independientemente de las
  asignaciones definidas globalmente en la función `ggplot()`.
- El signo `+` usado para agregar nuevas capas debe colocarse al final de la línea
  que contiene la capa _anterior_. If, instead, the `+` sign is
  added at the beginning of the line containing the new layer,
  `ggplot2` will not add the new layer and will return an error
  message.

```{r, eval=FALSE}
# This is the correct syntax for adding layers
rna_plot +
  geom_histogram()

# This will not add the new layer and will return an error message
rna_plot
  + geom_histogram()
```

## Construyendo sus parcelas de forma iterativa

Ahora dibujaremos un diagrama de dispersión con dos variables continuas y la función
`geom_point()`. Este gráfico representará los cambios log2
de la expresión que compara el tiempo 8 con el tiempo 0 y el tiempo 4 con el tiempo 0.
Para este fin, primero necesitamos calcular las medias de los valores de expresión
transformados logarítmicamente por gen y tiempo, luego el pliegue logarítmico cambia
restando las expresiones logarítmicas medias entre el tiempo 8 y el tiempo 0. y
entre el tiempo 4 y el tiempo 0. Tenga en cuenta que también incluimos aquí el biotipo del gen
que usaremos más adelante para representar los genes. Guardaremos
los cambios de pliegue en un nuevo marco de datos llamado `rna_fc.`

```{r rna_fc, cache=FALSE, purl=TRUE}
rna_fc <- rna %>% seleccionar(gen, tiempo,
                         biotipo_gen, registro_expresión) %>%
  group_by(gen, tiempo, biotipo_gen) %>%
  resumir(exp_media = mean(expression_log)) %>%
  pivot_wider(names_from = tiempo,
              valores_from = mean_exp) %>%
  mutate(time_8_vs_0 = `8` - `0`, time_4_vs_0 = `4` - `0`)

```

Luego podemos construir un ggplot con el conjunto de datos recién creado `rna_fc`.
La construcción de parcelas con `ggplot2` suele ser un proceso iterativo.
comenzamos definiendo el conjunto de datos que usaremos, diseñamos los ejes y elegimos una geom
:

```{r create-ggplot-object, cache=FALSE, purl=TRUE}
ggplot(datos = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point()
```

Luego, comenzamos a modificar este gráfico para extraer más información del mismo.
Por ejemplo, podemos agregar transparencia (`alfa`) para evitar el trazado excesivo:

```{r adding-transparency, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point(alpha = 0.3)
```

También podemos agregar colores para todos los puntos:

```{r adding-colors, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point(alpha = 0.3, color = "azul")
```

O para colorear cada gen en el gráfico de manera diferente, puede usar un vector como
una entrada para el argumento **color**. `ggplot2` proporcionará un color
diferente correspondiente a diferentes valores en el vector. Aquí hay un
ejemplo donde coloreamos con `gene_biotype`:

```{r color-by-gene_biotype1, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_point(alpha = 0.3, aes(color = gene_biotype))

```

También podemos especificar los colores directamente dentro del mapeo proporcionado en
la función `ggplot()`. Esto será visto por cualquier capa de geom y el mapeo
estará determinado por los ejes x e y configurados en `aes()`.

```{r color-by-gene_biotype2, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0,
                                color = gene_biotype)) +
  geom_point(alpha = 0.3)
```

Finalmente, también podríamos agregar una línea diagonal con la función `geom_abline()`
:

```{r adding-diag, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0,
                                color = gene_biotype)) +
  geom_point(alpha = 0.3) +
  geom_abline(intercept = 0)
```

Tenga en cuenta que podemos cambiar la capa geom de `geom_point` a
`geom_jitter` y los colores seguirán estando determinados por `gene_biotype`.

```{r color-by-gene_biotype3, cache=FALSE, purl=TRUE}
ggplot(data = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0,
                                color = gene_biotype)) +
  geom_jitter(alpha = 0.3) +
  geom_abline(intercept = 0)
```

```{r, echo=FALSE, message=FALSE}
biblioteca("hexbin")
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Los diagramas de dispersión pueden ser herramientas exploratorias útiles para conjuntos de datos pequeños. Para
conjuntos de datos con una gran cantidad de observaciones, como el conjunto de datos `rna_fc`
, el trazado excesivo de puntos puede ser una limitación de los diagramas de dispersión.
Una estrategia para manejar tales configuraciones es utilizar agrupación hexagonal de
observaciones. El espacio de la trama está teselado en hexágonos. A cada hexágono
se le asigna un color según el número de observaciones que
caen dentro de sus límites.

- Para utilizar la agrupación hexagonal en `ggplot2`, primero instale el paquete R
  `hexbin` de CRAN y cárguelo.

- Luego use la función `geom_hex()` para producir la figura hexbin.

- ¿Cuáles son las fortalezas y debilidades relativas de un diagrama de bin hexagonal
  en comparación con un diagrama de dispersión? Examine el diagrama de dispersión anterior
  y compárelo con el diagrama de bin hexagonal que creó.

::::::::::::::: solución

## Solución

```{r, eval=FALSE, purl=TRUE}
instalar.paquetes("hexbin")
```

```{r, purl=TRUE}
biblioteca("hexbin")

ggplot(data = rna_fc, mapeo = aes(x = time_4_vs_0, y = time_8_vs_0)) +
  geom_hex() +
  geom_abline(intercepción = 0 )

```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Utilice lo que acaba de aprender para crear un diagrama de dispersión de `expression_log`
sobre `sample` del conjunto de datos `rna` con el tiempo mostrado en
colores diferentes. ¿Es esta una buena manera de mostrar este tipo de datos?

::::::::::::::: solución

## Solución

```{r, eval=TRUE, purl=TRUE}
ggplot(datos = arn, mapeo = aes(y = expresión_log, x = muestra)) +
    geom_point(aes(color = tiempo))
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## diagrama de caja

Podemos usar diagramas de caja para visualizar la distribución de expresiones genéticas
dentro de cada muestra:

```{r boxplot, cache=FALSE, purl=TRUE}
ggplot(datos = rna,
         mapeo = aes(y = expresión_log, x = muestra)) +
  geom_boxplot()
```

Al agregar puntos al diagrama de caja, podemos tener una mejor idea del número de
mediciones y de su distribución:

```{r boxplot-with-points, cache=FALSE, purl=TRUE}
ggplot(datos = rna,
         mapeo = aes(y = expresión_log, x = muestra)) +
  geom_jitter(alfa = 0.2, color = "tomate") +
  geom_boxplot( alfa = 0)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

¿Observa cómo la capa del diagrama de caja está delante de la capa de fluctuación? ¿Qué
necesitas cambiar en el código para colocar el diagrama de caja debajo de los puntos?

::::::::::::::: solución

## Solución

Deberíamos cambiar el orden de estas dos geoms:

```{r boxplot-with-points2, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapeo = aes(y = expresión_log, x = muestra)) +
  geom_boxplot(alpha = 0) +
  geom_jitter(alpha = 0.2, color = "tomate")
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Puede notar que los valores en el eje x todavía no se pueden leer correctamente
. Cambiemos la orientación de las etiquetas y ajustémoslas
vertical y horizontalmente para que no se superpongan. Puedes usar un ángulo de
90 grados, o experimentar para encontrar el ángulo apropiado para
etiquetas orientadas en diagonal:

```{r boxplot-xaxis-rotated, cache=FALSE, purl=TRUE}
ggplot(datos = rna,
         mapeo = aes(y = expresión_log, x = muestra)) +
  geom_jitter(alfa = 0.2, color = "tomate") +
  geom_boxplot( alfa = 0) +
  tema(axis.text.x = element_text(ángulo = 90, hjust = 0.5, vjust = 0.5))
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Agregue color a los puntos de datos en su diagrama de caja de acuerdo con la duración
de la infección (`tiempo`).

_Pista:_ Verifique el "tiempo" de la clase. Considere cambiar la clase de
`time` de entero a factor directamente en el mapeo de ggplot. ¿Por qué
esto cambia la forma en que R hace el gráfico?

::::::::::::::: solución

## Solución

```{r boxplot-color-time, cache=FALSE, purl=TRUE}
# time as integer
ggplot(data = rna,
         mapping = aes(y = expression_log,
                       x = sample)) +
  geom_jitter(alpha = 0.2, aes(color = time)) +
  geom_boxplot(alpha = 0) +
  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))

# time as factor
ggplot(data = rna,
         mapping = aes(y = expression_log,
                       x = sample)) +
  geom_jitter(alpha = 0.2, aes(color = as.factor(time))) +
  geom_boxplot(alpha = 0) +
  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Los diagramas de caja son resúmenes útiles, pero ocultan la _forma_ de la distribución
. Por ejemplo, si la distribución es bimodal,
no la veríamos en un diagrama de caja. Una alternativa al diagrama de caja es el diagrama del violín
, donde se dibuja la forma (de la densidad de puntos).

- Reemplace el diagrama de caja con un diagrama de violín; ver `geom_violin()`. Rellena
  los violines según el tiempo con el argumento `fill`.

::::::::::::::: solución

## Solución

```{r, eval=TRUE, echo=TRUE, cache=FALSE, purl=TRUE}
ggplot(data = rna,
         mapeo = aes(y = expresión_log, x = muestra)) +
  geom_violin(aes(fill = as.factor(time))) +
  tema(axis.text.x = element_text(ángulo = 90, hjust = 0.5, vjust = 0.5))
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

- Modifique la trama del violín para completar los violines por "sexo".

::::::::::::::: solución

## Solución

```{r, eval=TRUE, echo=TRUE, cache=FALSE, purl=TRUE}
ggplot(datos = rna,
         mapeo = aes(y = expresión_log, x = muestra)) +
  geom_violin(aes(relleno = sexo)) +
  tema(eje.texto .x = elemento_texto(ángulo = 90, hjust = 0.5, vjust = 0.5))
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## Gráficos de líneas

Calculemos la expresión media por duración de la infección para
los 10 genes que tienen los cambios logarítmicos más altos comparando el tiempo 8 versus
tiempo 0. Primero, necesitamos seleccionar los genes y crear un subconjunto de `rna`
llamado `sub_rna` que contiene los 10 genes seleccionados, luego necesitamos agrupar
los datos y calcular la expresión génica media dentro cada grupo:

```{r, purl=TRUE}
rna_fc <- rna_fc %>% arrange(desc(time_8_vs_0))

genes_selected <- rna_fc$gene[1:10]

sub_rna <- rna %>%
    filter(gene %in% genes_selected)

mean_exp_by_time <- sub_rna %>%
  group_by(gene,time) %>%
    summarize(mean_exp = mean(expression_log))

mean_exp_by_time
```

Podemos construir el gráfico lineal con la duración de la infección en el eje x
y la expresión media en el eje y:

```{r first-time-series, purl=TRUE}
ggplot(datos = media_exp_por_tiempo, mapeo = aes(x = tiempo, y = media_exp)) +
  geom_line()
```

Desafortunadamente, esto no funciona porque representamos los datos de todos los genes
juntos. Necesitamos decirle a ggplot que dibuje una línea para cada gen
modificando la función estética para incluir `grupo = gen`:

```{r time-series-by-gene, purl=TRUE}
ggplot(datos = media_exp_por_tiempo,
       mapeo = aes(x = tiempo, y = media_exp, grupo = gen)) +
  geom_line()
```

Podremos distinguir genes en el gráfico si agregamos colores (usando
`color` también agrupa automáticamente los datos):

```{r time-series-with-colors, purl=TRUE}
ggplot(datos = media_exp_por_tiempo,
       mapeo = aes(x = tiempo, y = media_exp, color = gen)) +
  geom_line()
```

## facetado

`ggplot2` tiene una técnica especial llamada _facetado_ que permite al usuario
dividir un gráfico en múltiples (sub)gráficos en función de un factor incluido
en el conjunto de datos. Estas diferentes subtramas heredan las mismas propiedades
(límites de ejes, ticks, ...) para facilitar su comparación directa.
lo usaremos para hacer un gráfico lineal a lo largo del tiempo para cada gen:

```{r first-facet, purl=TRUE}
ggplot(datos = media_exp_por_tiempo,
       mapeo = aes(x = tiempo, y = media_exp)) + geom_line() +
  facet_wrap(~ gen)
```

Aquí, tanto el eje x como el y tienen la misma escala para todas las subtramas. Usted
puede cambiar este comportamiento predeterminado modificando `escalas` para permitir
una escala libre para el eje y:

```{r first-facet-scales, purl=TRUE}
ggplot(data = media_exp_por_tiempo,
       mapeo = aes(x = tiempo, y = media_exp)) +
  geom_line() +
  facet_wrap(~ gen, escalas = "free_y")
```

Ahora nos gustaría dividir la línea en cada gráfico por el sexo de los ratones.
Para hacer eso necesitamos calcular la expresión media en el marco de datos
agrupado por "gen", "tiempo" y "sexo":

```{r data-facet-by-gene-and-sex, purl=TRUE}
mean_exp_by_time_sex <- sub_rna %>%
  group_by(gen, tiempo, sexo) %>%
    resumen(mean_exp = mean(expression_log))

mean_exp_by_time_sex
```

Ahora podemos hacer el gráfico facetado dividiéndolo aún más por sexo usando
`color` (dentro de un solo gráfico):

```{r facet-by-gene-and-sex, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapeo = aes(x = tiempo, y = mean_exp, color = sexo)) +
  geom_line() +
  facet_wrap(~ gen, escalas = "libre_y")
```

Por lo general, los gráficos con fondo blanco parecen más legibles cuando se imprimen. Nosotros
podemos configurar el fondo en blanco usando la función `theme_bw()`.
Además, podemos eliminar la cuadrícula:

```{r facet-by-gene-and-sex-white-bg, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapeo = aes(x = tiempo, y = mean_exp, color = sexo)) +
  geom_line() +
  facet_wrap(~ gen, escalas = "free_y") +
  theme_bw() +
  tema(panel.grid = element_blank())
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Utilice lo que acaba de aprender para crear un gráfico que represente cómo cambia la expresión promedio
de cada cromosoma durante la duración de la infección
.

::::::::::::::: solución

## Solución

```{r mean-exp-chromosome-time-series, purl=TRUE}
mean_exp_by_chromosome <- arn %>%
  group_by(chromosome_name, time) %>%
  resumen(mean_exp = mean(expression_log))

ggplot(data = mean_exp_by_chromosome, mapeo = aes( x = tiempo,
                                y = media_exp)) +
  geom_line() +
  facet_wrap(~ nombre_cromosoma, escalas = "free_y")
```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

La geometría `facet_wrap` extrae gráficos en un número arbitrario de
dimensiones para permitir que quepan limpiamente en una página. On the other hand,
the `facet_grid` geometry allows you to explicitly specify how you want
your plots to be arranged via formula notation (`rows ~ columns`; a `.`
can be used as a placeholder that indicates only one row or column).

Modifiquemos el gráfico anterior para comparar cómo la expresión genética media
de hombres y mujeres ha cambiado a lo largo del tiempo:

```{r mean-exp-time-facet-sex-rows, purl=TRUE}
# Una columna, faceta por filas
ggplot(data = media_exp_by_time_sex,
       mapeo = aes(x = tiempo, y = media_exp, color = gen)) +
  geom_line() +
  facet_grid(sexo ~ .)
```

```{r mean-exp-time-facet-sex-columns, purl=TRUE}
# Una fila, faceta por columna
ggplot(data = media_exp_by_time_sex,
       mapeo = aes(x = tiempo, y = media_exp, color = gen)) +
  geom_line() +
  facet_grid(. ~ sexo)
```

## temas `ggplot2`

Además de `theme_bw()`, que cambia el fondo de la trama a blanco,
`ggplot2` viene con varios otros temas que pueden ser útiles para
cambiar rápidamente el aspecto de tu visualización. La lista completa de temas está
disponible en [https://ggplot2.tidyverse.org/reference/ggtheme.html](https://ggplot2.tidyverse.org/reference/ggtheme.html).
`theme_minimal()` y `theme_light()` son populares, y `theme_void()`
puede ser útil como punto de partida para crear un nuevo tema hecho a mano.

El paquete [ggthemes](https://jrnold.github.io/ggthemes/reference/index.html)
proporciona una amplia variedad de opciones (incluido un tema de Excel 2003
). The ggplot2 provides a list of
packages that extend the capabilities of `ggplot2`, including additional
themes.

## Personalización

Volvamos a la trama facetada de expresión media por tiempo y gen,
coloreada por sexo.

Eche un vistazo a la hoja de trucos ,
y piense en formas Podrías mejorar la trama.

Ahora, podemos cambiar los nombres de los ejes a algo más informativo que
'tiempo' y 'media\_exp', y agregar un título a la figura:

```{r mean_exp-time-with-right-labels, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapeo = aes(x = tiempo, y = mean_exp, color = sexo)) +
  geom_line() +
  facet_wrap(~ gen, escalas = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(title = "Expresión genética media por duración de la infección",
       x = "Duración de la infección (en días)",
       y = "Expresión genética media")
```

Los ejes tienen nombres más informativos, pero su legibilidad se puede mejorar
aumentando el tamaño de fuente:

```{r mean_exp-time-with-right-labels-xfont-size, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapeo = aes(x = tiempo, y = mean_exp, color = sexo)) +
  geom_line() +
  facet_wrap(~ gen, escalas = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(title = "Expresión genética media por duración de la infección",
       x = "Duración de la infección (en días)",
       y = "Expresión genética media") +
  tema(texto = elemento_texto(tamaño = 16))
```

Tenga en cuenta que también es posible cambiar las fuentes de sus gráficos. Si
estás en Windows, es posible que tengas que instalar el [**`extrafont`**
paquete](https://cran.r-project.org/web/packages/extrafont /index.html).

Podemos personalizar aún más el color del texto de los ejes x e y, el color de
la cuadrícula, etc. También podemos, por ejemplo, mover la leyenda a la parte superior
configurando `legend.position` en `"top"`.

```{r mean_exp-time-with-theme, cache=FALSE, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(title = "Mean gene expression by duration of the infection",
       x = "Duration of the infection (in days)",
       y = "Mean gene expression")  +
  theme(text = element_text(size = 16),
        axis.text.x = element_text(colour = "royalblue4", size = 12),
        axis.text.y = element_text(colour = "royalblue4", size = 12),
        panel.grid = element_line(colour="lightsteelblue1"),
        legend.position = "top")
```

Si le gustan más los cambios que creó que el tema predeterminado,
puede guardarlos como un objeto para poder aplicarlos fácilmente a otros
gráficos que pueda crear. Aquí hay un ejemplo con el histograma que hemos
creado previamente.

```{r mean_exp-time-with-right-labels-xfont, cache=FALSE, purl=TRUE}
blue_theme <- theme(axis.text.x = element_text(colour = "royalblue4",
                                               size = 12),
                    axis.text.y = element_text(colour = "royalblue4",
                                               size = 12),
                    text = element_text(size = 16),
                    panel.grid = element_line(colour="lightsteelblue1"))

ggplot(rna, aes(x = expression_log)) +
  geom_histogram(bins = 20) +
    blue_theme
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Desafío

Con toda esta información en la mano, tómate otros cinco minutos
para mejorar uno de los gráficos generados en este ejercicio o
para crear un hermoso gráfico propio. Utilice la hoja de trucos
de RStudio ggplot2
para inspirarse. Aquí hay algunas ideas:

- Vea si puede cambiar el grosor de las líneas.
- ¿Puedes encontrar una manera de cambiar el nombre de la leyenda? ¿Qué pasa con
  sus etiquetas? (pista: busque una función ggplot que comience con
  `scale_`)
- Intente usar una paleta de colores diferente o especifique manualmente los
  colores para las líneas (consulte
  [http://www.cookbook-r.com/Graphs/Colors\_(ggplot2)/](https://www.cookbook-r.com/Graphs/Colors_\\(ggplot2\\)/)).

::::::::::::::: solución

## Solución

Por ejemplo, basado en esta trama:

```{r, purl=TRUE}
ggplot(data = mean_exp_by_time_sex,
       mapeo = aes(x = tiempo, y = mean_exp, color = sexo)) +
  geom_line() +
  facet_wrap(~ gen, escalas = "free_y") +
  theme_bw() +
  tema(panel.grid = element_blank())
```

Podemos personalizarlo de las siguientes maneras:

```{r, purl=TRUE}
# change the thickness of the lines
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line(size=1.5) +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank())

# change the name of the legend and the labels
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  scale_color_discrete(name = "Gender", labels = c("F", "M"))

# using a different color palette
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  scale_color_brewer(name = "Gender", labels = c("F", "M"), palette = "Dark2")

# manually specifying the colors
ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  scale_color_manual(name = "Gender",  labels = c("F", "M"),
                     values = c("royalblue", "deeppink"))

```

::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::::::::

## Componer tramas

Faceting is a great tool for splitting one plot into multiple subplots,
but sometimes you may want to produce a single figure that contains
multiple independent plots, i.e. plots that are based on different
variables or even different data frames.

Comencemos creando los dos gráficos que queremos organizar uno al lado del otro:
:

El primer gráfico cuenta el número de genes únicos por cromosoma.
primero necesitamos reordenar los niveles de `chromosome_name` y filtrar los
genes únicos por cromosoma. También cambiamos la escala del eje y a una escala
log10 para una mejor legibilidad.

```{r sub1, purl=TRUE}
arn$chromosome_name <- factor(arn$chromosome_name,
                               niveles = c(1:19,"X","Y"))

count_gene_chromosome <- arn %> % select(nombre_cromosoma, gen) %>%
  distintivo() %>% ggplot() +
  geom_bar(aes(x = nombre_cromosoma), fill = "verdemar",
           posición = "esquivar", estadística = "contar") +
  labs(y = "log10(n genes)", x = "cromosoma") +
  scale_y_log10()

recuento_gene_cromosoma
```

A continuación, también eliminamos la leyenda por completo estableciendo
`legend.position` en `"none"`.

```{r sub2, purl=TRUE}
exp_boxplot_sex <- ggplot(rna, aes(y=expression_log, x = as.factor(time),
                 color=sex)) +
   geom_boxplot(alpha = 0) +
  labs(y = "Experiencia genética media",
       x = "tiempo") + theme(legend.position = "none")

exp_boxplot_sex
```

El paquete [**patchwork**](https://github.com/thomasp85/patchwork)
proporciona un enfoque elegante para combinar figuras usando `+` para
organizar figuras (normalmente de lado). al lado). Más específicamente, `|`
los organiza explícitamente uno al lado del otro y `/` los apila uno encima del otro
.

```{r install-patchwork, message=FALSE, eval=FALSE, purl=TRUE}
instalar.paquetes("patchwork")
```

```{r patchworkplot1, purl=TRUE}
biblioteca("patchwork")
count_gene_chromosome + exp_boxplot_sex
## o count_gene_chromosome | exp_boxplot_sexo
```

```{r patchwork2, purl=TRUE}
count_gene_chromosome / exp_boxplot_sex
```

Podemos combinar un mayor control del diseño de la composición final con
`plot_layout` para crear diseños más complejos:

```{r patchwork3, purl=TRUE}
count_gene_chromosome + exp_boxplot_sex + plot_layout(ncol = 1)
```

```{r patchwork4, purl=TRUE}
count_gene_chromosome +
 (count_gene_chromosome + exp_boxplot_sex) +
 exp_boxplot_sex +
 plot_layout(ncol = 1)
```

El último gráfico también se puede crear usando los compositores `|` y `/`:

```{r patchwork5, purl=TRUE}
count_gene_chromosome /
 (count_gene_chromosome | exp_boxplot_sex) /
 exp_boxplot_sex
```

Obtenga más información sobre `patchwork` en su
[página web](https://patchwork.data-imaginist.com/) o en este
[video](https://www.youtube. es/watch?v=0m4yywqNPVY).

Otra opción es el paquete **`gridExtra`** que permite combinar
ggplots separados en una sola figura usando `grid.arrange()`:

```{r install-gridextra, message=FALSE, eval=FALSE, purl=TRUE}
instalar.paquetes("gridExtra")
```

```{r gridarrange-example, message=FALSE, fig.width=10, purl=TRUE}
biblioteca("gridExtra")
grid.arrange(count_gene_chromosome, exp_boxplot_sex, ncol = 2)
```

Además de los argumentos `ncol` y `nrow`, utilizados para hacer arreglos
simples, existen herramientas para [construir diseños
más complejos](https://cran.r-project. org/web/packages/gridExtra/vignettes/arrangeGrob.html).

## Exportar parcelas

Después de crear su trama, puede guardarla en un archivo en su formato
favorito. La pestaña Exportar en el panel **Trazado** en RStudio guardará sus
trazados en baja resolución, lo que no será aceptado por muchas revistas y
no se escalará bien para los carteles.

En su lugar, use la función `ggsave()`, que le permite cambiar fácilmente la dimensión
y la resolución de su gráfico ajustando los argumentos
apropiados (`ancho`, `alto` y `dpi` ).

Asegúrese de tener la carpeta `fig_output/` en su directorio de trabajo.

```{r ggsave-example, eval=FALSE, purl=TRUE}
my_plot <- ggplot(data = mean_exp_by_time_sex,
       mapping = aes(x = time, y = mean_exp, color = sex)) +
  geom_line() +
  facet_wrap(~ gene, scales = "free_y") +
  labs(title = "Mean gene expression by duration of the infection",
         x = "Duration of the infection (in days)",
         y = "Mean gene expression") +
  guides(color=guide_legend(title="Gender")) +
  theme_bw() +
  theme(axis.text.x = element_text(colour = "royalblue4", size = 12),
        axis.text.y = element_text(colour = "royalblue4", size = 12),
        text = element_text(size = 16),
        panel.grid = element_line(colour="lightsteelblue1"),
        legend.position = "top")
ggsave("fig_output/mean_exp_by_time_sex.png", my_plot, width = 15,
       height = 10)

# This also works for grid.arrange() plots
combo_plot <- grid.arrange(count_gene_chromosome, exp_boxplot_sex,
                           ncol = 2, widths = c(4, 6))
ggsave("fig_output/combo_plot_chromosome_sex.png", combo_plot,
       width = 10, dpi = 300)
```

Nota: Los parámetros `ancho` y `alto` también determinan el tamaño de fuente
en el gráfico guardado.

```{r final-challenge, eval=FALSE, purl=TRUE, echo=FALSE}
### Desafío de trama final:
## Con toda esta información en la mano, tómate otros cinco
## minutos para mejorar una de las tramas generadas en este
# # Haz ejercicio o crea un hermoso gráfico propio. Utilice la hoja de referencia de RStudio
## ggplot2 para inspirarse:
## https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf
```

## Otros paquetes para visualización.

`ggplot2` es un paquete muy poderoso que encaja muy bien en nuestra canalización de datos \*tidy* y _herramientas tidy_. Hay otros paquetes de visualización
  en R que no deben ignorarse.

### Gráficos básicos

El sistema de gráficos predeterminado que viene con R, a menudo llamado _base R
gráficos_ es simple y rápido. Se basa en el \*modelo de pintor o lienzo
\*, donde diferentes resultados se superponen directamente uno encima del otro
(consulte la figura @ref(fig:paintermodel)). This is a fundamental
difference with `ggplot2` (and with `lattice`, described below), that
returns dedicated objects, that are rendered on screen or in a file, and
that can even be updated.

```{r paintermodel, fig.width=12, fig.height=4, fig.cap="Successive layers added on top of each other."}
par(mfrow = c(1, 3))
plot(1:20, main = "Primera capa, producida con plot(1:20)")

plot(1:20, main = "Una línea roja horizontal, agregada con abline(h = 10)")
abline(h = 10, col = "red")

plot(1:20, main = "Un rectángulo , agregado con rect(5, 5, 15, 15)")
abline(h = 10, col = "red")
rect(5, 5, 15, 15, lwd = 3 )
```

Otra diferencia principal es que la función de trazado de los gráficos base intenta
hacer _lo correcto_ según su tipo de entrada, es decir, adaptarán
su comportamiento según la clase de su entrada. De nuevo, esto es muy
diferente de lo que tenemos en `ggplot2`, que solo acepta marcos de datos
como entrada y que requiere que los gráficos se construyan poco a poco.

```{r plotmethod, fig.width=8, fig.height=8, fig.cap="Plotting boxplots (top) and histograms (bottom) vectors (left) or a matrices (right)."}
par(mfrow = c(2, 2))
boxplot(rnorm(100),
        main = "Gráfico de caja de rnorm(100)")
boxplot(matrix(rnorm( 100), ncol = 10),
        main = "Gráfico de caja de la matriz(rnorm(100), ncol = 10)")
hist(rnorm(100))
hist( matriz(norma(100), ncol = 10))
```

El enfoque listo para usar en gráficos base puede ser muy eficiente para
figuras simples y estándar, que se pueden producir muy rápidamente con una sola línea de código
y una sola función, como `trama`, o `hist`, o
`boxplot`, ... Sin embargo, los valores predeterminados no siempre son los más atractivos
y el ajuste de las figuras, especialmente cuando se vuelven más complejos (por ejemplo,
para producir facetas), puede volverse largo y engorroso.

### El paquete de celosía

El paquete **`lattice`** es similar a `ggplot2` en el sentido de que utiliza
marcos de datos como entrada, devuelve objetos gráficos y admite facetado.
Sin embargo, `lattice` no se basa en la gramática de los gráficos y tiene una interfaz más
complicada.

Una buena referencia para el paquete `lattice` es @latticebook.

:::::::::::::::::::::::::::::::::::::::: puntos clave

- Visualización en R

::::::::::::::::::::::::::::::::::::::::::::::::::::::::
