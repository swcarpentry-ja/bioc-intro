---
source: 放射科
title: 从数据开始
teaching: 三十
exercises: 三十
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- 描述什么是“data.frame”。
- 将 .csv 文件中的外部数据加载到数据框中。
- 总结数据框的内容。
- 描述什么是因素。
- 在字符串和因子之间转换。
- 重新排序并重命名因素。
- 格式化日期。
- 导出并保存数据。

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- 使用 R 进行首次数据分析

:::::::::::::::::::::::::::::::::::::::::::::::::::::

> 本集基于 Data Carpentries 的_面向生态学家的 R 语言数据分析和
> 可视化_课程。

## 基因表达数据的呈现

我们将使用 Blackmore  发布的部份数据，\*
上呼吸道感染对
中枢神经系统转录组变化的影响\*。 该研究的目的是确定
上呼吸道感染对感染后小脑和脊髓中发生的
RNA 转录变化的影响。 性别匹配的八只
周龄 C57BL/6 小鼠通过
鼻内途径接种盐水或甲型流感病毒，并在第 0
（未感染）、第 4 和第 8 天通过 RNA-seq 评估小脑和
脊髓组织中的转录组变化。

数据集存储为逗号分隔值（CSV）文件。  每一行
包含单个 RNA 表达测量的信息，前十一列
代表：

| 柱子 | 描述                   |
| -- | -------------------- |
| 基因 | 被测量的基因名称             |
| 样本 | 测量基因表达的样本名称          |
| 表达 | 基因表达的价值              |
| 生物 | 生物体/物种 - 此处所有数据均来自小鼠 |
| 年龄 | 小鼠的年龄（这里所有的小鼠都是8周龄）  |
| 性别 | 老鼠的性别                |
| 感染 | 小鼠的感染状态，即感染甲型流感或未感染。 |
| 拉紧 | A 型流感病毒株。            |
| 时间 | 感染持续时间（以天为单位）。       |
| 组织 | 用于基因表达实验的组织，即小脑或脊髓。  |
| 老鼠 | 鼠标唯一标识符。             |

我们将使用 R 函数 `download.file()` 下载包含基因表达数据的
CSV 文件，并使用
`read.csv()` 将 CSV 文件的内容作为
类 `data.frame` 的对象加载到内存中。  在 `download.file` 命令中，
第一个条目是带有源 URL 的字符串。 此源 URL
从 GitHub 存储库下载 CSV 文件。
逗号后面的文本（“data/rnaseq.csv”）是该文件在您
本地机器上的目标位置。 您需要在您的机器上建立一个名为
`“data”`的文件夹，您将在该文件夹中下载文件。 因此，此命令下载
远程文件，将其命名为“rnaseq.csv”并将其添加到名为“data”的预先存在的
文件夹中。

```{r, eval=TRUE}
download.file(url = "https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv",
              destfile = "data/rnaseq.csv")
```

您现在可以加载数据了：

```{r, eval=TRUE, purl=TRUE}
rna <- read.csv("data/rnaseq.csv")
```

此语句不会产生任何输出，因为您可能
还记得，分配不会显示任何内容。 如果我们想检查
我们的数据是否已加载，我们可以通过
输入其名称来查看数据框的内容：

```{r, eval=FALSE}
rna
```

哇... 那是大量的输出。 至少这意味着数据已正确加载
。 让我们使用函数“head()”检查这个数据框
的顶部（前 6 行）：

```{r, purl=TRUE}
head(rna)
## Try also
## View(rna)
```

**笔记**

`read.csv()` 假定字段由逗号分隔，但是在
几个国家/地区，逗号用作小数分隔符，而
分号 (;) 用作字段分隔符。 如果您想在 R 中读取
这种类型的文件，您可以使用 `read.csv2()` 函数。 它的
行为与 `read.csv()` 完全相同，但对
小数点和字段分隔符使用不同的参数。 如果您使用另一种
格式，则用户可以同时指定它们。 通过输入 `?read.csv` 查看
`read.csv()` 的帮助以了解更多信息。 还有
`read.delim()` 函数用于读取制表符分隔的数据文件。 值得注意的是
所有这些函数实际上都是
主`read.table()`函数的包装函数，具有不同的参数。  因此，
上述数据也可以通过使用 `read.table()`
以分隔参数 `,` 来加载。 代码如下：

```{r, eval=TRUE, purl=TRUE}
rna <- read.table(file = "data/rnaseq.csv",
                  sep = ",",
                  header = TRUE)
```

必须将 header 参数设置为 TRUE 才能读取
标题，因为默认情况下 `read.table()` 将 header 参数设置为
FALSE。

## 什么是数据框？

数据框是大多数表格数据的_事实上的_数据结构，
以及我们用于统计和绘图的数据结构。

A data frame can be created by hand, but most commonly they are
generated by the functions `read.csv()` or `read.table()`; in other
words, when importing spreadsheets from your hard drive (or the web).

数据框是以表格
格式表示的数据，其中列是所有具有相同长度的向量。 因为
列是向量，所以每一列必须包含单一类型的数据
（例如，字符、整数、因子）。 例如，这里有一个图
，描绘了一个包含数字、字符和
逻辑向量的数据框。

![](./图/数据框.svg)

当我们用函数 `str()` 检查数据框
的 <b>str</b>结构时，我们可以看到这一点：

```{r}
str(rna)
```

## 检查 `data.frame` 对象

我们已经看到了函数“head()”和“str()”如何有助于
检查数据框的内容和结构。 这里有一个
非详尽的函数列表，可以帮助您了解
数据的内容/结构。 让我们尝试一下吧！

**尺寸**：

- `dim(rna)` - 返回一个向量，其行数作为第一个
  元素，列数作为第二个元素（对象的
  **维度**）。
- `nrow(rna)`——返回行数。
- `ncol(rna)`——返回列数。

**内容**：

- `head(rna)`-显示前 6 行。
- `tail(rna)`-显示最后 6 行。

**姓名**：

- `names(rna)` - 返回列名（对于
  `data.frame` 对象，`colnames()` 的同义词）。
- `rownames(rna)` - 返回行名称。

**概括**：

- `str(rna)`——对象的结构和有关
  类、长度和每列内容的信息。
- `summary(rna)`——每列的汇总统计数据。

注意：这些函数大部分都是“通用的”，除了“data.frame”之外，它们还可以用于其他类型的
对象。

:::::::::::::::::::::::::::::::::::::::  challenge

## 挑战：

根据 `str(rna)` 的输出，你能回答以下
个问题吗？

- 对象“rna”的类别是什么？
- 这个对象有多少行、多少列？

:::::::::::::::  solution

## 解决方案

- 类别：数据框
- 行数：66465，列数：11

:::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::

## 索引和子集数据框

我们的 `rna` 数据框有行和列（它有 2 个维度）；如果我们
想从中提取一些特定数据，我们需要指定我们想要的
“坐标”。 行号在前，然后是
列号。 但是，请注意，指定这些
坐标的不同方式会导致不同类别的结果。

```{r, eval=FALSE, purl=TRUE}
# first element in the first column of the data frame (as a vector)
rna[1, 1]
# first element in the 6th column (as a vector)
rna[1, 6]
# first column of the data frame (as a vector)
rna[, 1]
# first column of the data frame (as a data.frame)
rna[1]
# first three elements in the 7th column (as a vector)
rna[1:3, 7]
# the 3rd row of the data frame (as a data.frame)
rna[3, ]
# equivalent to head_rna <- head(rna)
head_rna <- rna[1:6, ]
head_rna
```

`:` 是一个特殊函数，它按
的升序或降序创建整数数值向量，例如对
实例测试 `1:10` 和 `10:1`。 有关详细信息，请参阅部分@ref(sec:genvec)。

您还可以使用“-”符号排除数据框的某些索引：

```{r, eval=FALSE, purl=TRUE}
rna[, -1]          ## The whole data frame, except the first column
rna[-c(7:66465), ] ## Equivalent to head(rna)
```

数据框可以通过调用索引（如前所示）
进行子集化，也可以通过直接调用其列名进行子集化：

```{r, eval=FALSE, purl=TRUE}
rna["gene"]       # Result is a data.frame
rna[, "gene"]     # Result is a vector
rna[["gene"]]     # Result is a vector
rna$gene          # Result is a vector
```

In RStudio, you can use the autocompletion feature to get the full and
correct names of the columns.

:::::::::::::::::::::::::::::::::::::::  challenge

## 挑战

1. 创建一个 `data.frame` (`rna_200`)，其中仅包含 `rna` 数据集中
   行 200 中的数据。

2. 注意“nrow()”如何给出“data.frame”中的行数？

- 使用该数字提取初始
  `rna` 数据框中的最后一行。

- 将其与您看到的最后一行进行比较，使用`tail()`到
  确保它符合预期。

- 使用“nrow()”而不是行号来拉出最后一行。

- 从最后一行创建一个新的数据框（“rna_last”）。

3. 使用 `nrow()` 提取位于
   `rna` 数据框中间的行。 将此行的内容存储在名为“rna_middle”的对象
   中。

4. 将 `nrow()` 与上面的 `-` 符号结合起来，重现 `head(rna)` 的
   行为，仅保留 rna 数据集的第一到第六个
   行。

:::::::::::::::  solution

## 解决方案

```{r, purl=TRUE}
## 1.
rna_200 <- rna[200, ]
## 2.
## Saving `n_rows` to improve readability and reduce duplication
n_rows <- nrow(rna)
rna_last <- rna[n_rows, ]
## 3.
rna_middle <- rna[n_rows / 2, ]
## 4.
rna_head <- rna[-(7:n_rows), ]
```

:::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::

## 因素

因素代表**分类数据**。 它们存储为与标签相关的整数
，并且可以有序或无序。 While
factors look (and often behave) like character vectors, they are
actually treated as integer vectors by R. So you need to be very
careful when treating them as strings.

一旦创建，因素只能包含一组预定义的值，
称为_级别_。 默认情况下，R 总是按字母顺序
对级别进行排序。 例如，如果你有一个具有 2 个级别的因子：

```{r, purl=TRUE}
sex <- factor(c("male", "female", "female", "male", "female"))
```

R 将为级别“女性”分配“1”，为级别
“男性”分配“2”（因为“f”位于“m”之前，即使此向量中的第一个元素
是“男性”）。 您可以使用函数
`levels()` 来看到这一点，并且可以使用 `nlevels()` 来找到级别的数量：

```{r, purl=TRUE}
levels(sex)
nlevels(sex)
```

有时，因素的顺序并不重要，有时你
可能想要指定顺序，因为它很有意义（例如，“低”，
，“中”，“高”），它可以改善你的可视化，或者它是特定类型的分析所必需的
。 这里，重新排序“性别”向量中的级别
的一种方法是：

```{r, purl=TRUE}
sex ## current order
sex <- factor(sex, levels = c("male", "female"))
sex ## after re-ordering
```

在 R 的内存中，这些因素由整数 (1, 2, 3) 表示，
但比整数更具信息量，因为因素是自我
描述的：“女性”、“男性”比 `1`、
`2` 更具描述性。 哪一个是“男性”？  您无法仅从
整数数据来判断。 另一方面，因素本身就包含这些信息。
当存在多个级别时它特别有用（例如我们的示例数据集中的
基因生物型）。

当您的数据被存储为一个因子时，您可以使用 `plot()`
函数快速浏览每个因子级别所代表的观测值
的数量。 让我们看看数据中的男性
和女性的数量。

```{r firstfactorplot, fig.cap="Bar plot of the number of females and males.", purl=TRUE}
plot(sex)
```

### 转换为字符

如果您需要将因子转换为字符向量，则可以使用
`as.character(x)`。

```{r, purl=TRUE}
as.character(sex)
```

<!-- ### Numeric factors -->

<!-- Converting factors where the levels appear as numbers (such as -->

<!-- concentration levels, or years) to a numeric vector is a little -->

<!-- trickier. The `as.numeric()` function returns the index values of the -->

<!-- factor, not its levels, so it will result in an entirely new (and -->

<!-- unwanted in this case) set of numbers.  One method to avoid this is to -->

<!-- convert factors to characters, and then to numbers.  Another method is -->

<!-- to use the `levels()` function. Compare: -->

<!-- ```{r} -->

<!-- year_fct <- factor(c(1990, 1983, 1977, 1998, 1990)) -->

<!-- as.numeric(year_fct)  ## Wrong! And there is no warning... -->

<!-- as.numeric(as.character(year_fct)) ## Works... -->

<!-- as.numeric(levels(year_fct))[year_fct] ## The recommended way. -->

<!-- ```

<!-- Notice that in the `levels()` approach, three important steps occur: -->

<!-- * We obtain all the factor levels using `levels(year_fct)` -->

<!-- * We convert these levels to numeric values using `as.numeric(levels(year_fct))` -->

<!-- * We then access these numeric values using the underlying integers of the -->

<!--   vector `year_fct` inside the square brackets -->

### 重命名因素

如果我们想重命名这些因素，只需改变其
级别即可：

```{r, purl=TRUE}
levels(sex)
levels(sex) <- c("M", "F")
sex
plot(sex)
```

::::::::::::::::::::::::::::::::::::::  challenge

## 挑战：

- 将“F”和“M”分别重命名为“女性”和“男性”。

:::::::::::::::  solution

## 解决方案

```{r, eval=TRUE, purl=TRUE}
levels(sex)
levels(sex) <- c("Male", "Female")
```

:::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## 挑战：

我们已经看到了使用“read.csv()”时如何创建数据框，但是
也可以使用“data.frame()”函数手动创建它们。
这个手工制作的“data.frame”中存在一些错误。 你能
发现并修复它们吗？  不要犹豫去尝试吧！

```{r, eval=FALSE}
animal_data <- data.frame(
       animal = c(dog, cat, sea cucumber, sea urchin),
       feel = c("furry", "squishy", "spiny"),
       weight = c(45, 8 1.1, 0.8))
```

:::::::::::::::  solution

## 解决方案

- 动物名称周围缺少引号
- “感觉”栏中缺少一项（可能是针对其中一种毛茸茸的动物）
- 体重栏缺少一个逗号

:::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## 挑战：

您能预测以下
示例中每一列的类别吗？

使用 `str(country_climate)` 检查你的猜测：

- 它们符合你的预期吗？  为什么？ 为什么不？

- 在创建数据框时，通过在最后一个
  变量后添加 `stringsAsFactors = TRUE` 再试一次。 现在发生了什么事？
  当使用“read.csv()”将基于文本的
  电子表格读入 R 时，也可以设置“stringsAsFactors”。

```{r, eval=FALSE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "South Africa", "Australia"),
       climate = c("cold", "hot", "temperate", "hot/temperate"),
       temperature = c(10, 30, 18, "15"),
       northern_hemisphere = c(TRUE, TRUE, FALSE, "FALSE"),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
       )
```

:::::::::::::::  solution

## 解决方案

```{r, eval=TRUE, purl=TRUE}
country_climate <- data.frame(
       country = c("Canada", "Panama", "South Africa", "Australia"),
       climate = c("cold", "hot", "temperate", "hot/temperate"),
       temperature = c(10, 30, 18, "15"),
       northern_hemisphere = c(TRUE, TRUE, FALSE, "FALSE"),
       has_kangaroo = c(FALSE, FALSE, FALSE, 1)
       )
str(country_climate)
```

:::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::

The automatic conversion of data type is sometimes a blessing, sometimes an
annoyance. 请注意它的存在，学习规则，并仔细检查您在 R 中导入的数据
在您的数据框内是否属于正确类型。 如果没有，请利用它
来检测在数据
输入期间可能引入的错误（例如，某一列中应该只包含数字的字母）。

欲了解更多信息，请参阅 RStudio
教程

## 矩阵

在继续之前，既然我们已经了解了数据框，让我们
回顾一下包安装并了解一种新的数据类型，即
“矩阵”。 与“数据框”类似，矩阵有两个维度：行和
列。 但主要的区别在于“矩阵”中的所有单元格必须
属于同一类型：“数字”、“字符”、“逻辑”…… 从
方面来看，矩阵更接近于“向量”而不是“数据框”。

矩阵的默认构造函数是“矩阵”。 它采用
值的向量来填充矩阵和行数和/或
列数[^ncol]。 这些值按照列排序，如下图所示
。

```{r mat1, purl=TRUE}
m <- matrix(1:9, ncol = 3, nrow = 3)
m
```

[^ncol]: 行数或列数就足够了，因为另一个可以从值的长度推断出来。 尝试一下如果值和行数/列数不相加会发生什么。

:::::::::::::::::::::::::::::::::::::::  challenge

## 挑战：

使用函数“installed.packages()”，创建一个“字符”矩阵
，其中包含有关当前安装在
计算机上的所有包的信息。 探索它。

:::::::::::::::  solution

## 解决方案：

```{r pkg_sln, eval=FALSE, purl=TRUE}
## create the matrix
ip <- installed.packages()
head(ip)
## try also View(ip)
## number of package
nrow(ip)
## names of all installed packages
rownames(ip)
## type of information we have about each package
colnames(ip)
```

:::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::

创建大型随机数据矩阵作为测试
数据通常很有用。 下面的练习要求你创建这样一个矩阵，其中包含从均值为 0、标准差为
1 的正态分布中抽取的随机
数据，这可以使用 `rnorm()` 函数完成。

:::::::::::::::::::::::::::::::::::::::  challenge

## 挑战：

构建一个维度为 1000、长度为 3 的正态分布数据矩阵
（平均值为 0，标准差为 1）

:::::::::::::::  solution

## 解决方案

```{r rnormmat_sln, purl=TRUE}
set.seed(123)
m <- matrix(rnorm(3000), ncol = 3)
dim(m)
head(m)
```

:::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::::::::::::

## 格式化日期

最常见的问题之一是新手（和经验丰富的人！） R 用户有
将日期和时间信息转换为
适当且可在分析期间使用的变量。

### 注意电子表格程序中的日期

电子表格中的日期通常存储在单个列中。 虽然
这似乎是记录日期最自然的方式，但实际上它并不是
最佳做法。 电子表格应用程序将以
看似正确的方式（对于人类观察者而言）显示日期，但它实际
处理和存储日期的方式可能会有问题。 It is often much
safer to store dates with YEAR, MONTH and DAY in separate columns or
as YEAR and DAY-OF-YEAR in separate columns.

电子表格程序，例如 LibreOffice、Microsoft Excel、OpenOffice、
Gnumeric、... 有不同的（并且通常不兼容的）方式来编码
日期（即使对于同一程序，不同版本和操作系统也存在不同的
）。 此外，Excel 可以 将非日期的内容转换为
日期
(@Zeeberg:2004)，例如 MAR1、DEC1、
OCT4 等名称或标识符。 因此，如果您总体上避免使用日期格式，则
更容易识别这些问题。

数据木工课程的 日期为
数据
部分提供了有关电子表格中日期缺陷的额外见解
。

我们将使用包
**`lubridate`** 中的 `ymd()` 函数（属于 **`tidyverse`**；了解更多信息
[这里](https://www.tidyverse.org/)）。 。 **`lubridate`** 作为 **`tidyverse`** 安装的一部分进行安装
。 当你加载
**`tidyverse`** (`library(tidyverse)`) 时，核心包（大多数数据分析中使用的
包）也会被加载。 然而，**`lubridate`**
不属于核心 tidyverse，因此您必须使用 `library(lubridate)` 明确加载它
。

首先加载所需的包：

```{r loadlibridate, message=FALSE, purl=TRUE}
library("lubridate")
```

`ymd()` 采用代表年、月、日的向量，并将
转换为 `Date` 向量。 `日期` 是 R 识别的一类数据，
表示日期，并且可以这样进行操作。
函数所需的参数很灵活，但最佳实践是将字符
向量格式化为“YYYY-MM-DD”。

让我们创建一个日期对象并检查其结构：

```{r, purl=TRUE}
my_date <- ymd("2015-01-01")
str(my_date)
```

现在让我们分别粘贴年份、月份和日期——我们得到相同的结果：

```{r, purl=TRUE}
# sep indicates the character to use to separate each component
my_date <- ymd(paste("2015", "1", "1", sep = "-"))
str(my_date)
```

现在让我们熟悉典型的日期操作
管道。 The small data below has stored dates in different `year`,
`month` and `day` columns.

```{r, purl=TRUE}
x <- data.frame(year = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),
                month = c(2,  3,  3, 10,  1,  8,  3,  4,  5,  5),
                day = c(24,  8,  1,  5,  8, 17, 13, 10, 11, 24),
                value = c(4,  5,  1,  9,  3,  8, 10,  2,  6,  7))
x
```

现在我们将此函数应用于“x”数据集。 我们首先使用 `paste()` 从 `x`
的 `year`、`month` 和 `day` 列创建一个
字符向量：

```{r, purl=TRUE}
paste(x$year, x$month, x$day, sep = "-")
```

该字符向量可用作 `ymd()` 的参数：

```{r, purl=TRUE}
ymd(paste(x$year, x$month, x$day, sep = "-"))
```

生成的 `Date` 向量可以添加到 `x` 作为名为 `date` 的新列：

```{r, purl=TRUE}
x$date <- ymd(paste(x$year, x$month, x$day, sep = "-"))
str(x) # notice the new column, with 'date' as the class
```

让我们确保一切正常。 检查
新列的一种方法是使用 `summary()`：

```{r, purl=TRUE}
summary(x$date)
```

请注意，`ymd()` 需要按
的顺序显示年、月、日。 例如，如果您有日、月和年，您将需要
`dmy()`。

```{r, purl=TRUE}
dmy(粘贴(x$day, x$month, x$year, sep = "-"))
```

`lubdridate` 有许多函数可以解决所有日期变化。

## R 对象摘要

到目前为止，我们已经看到了几种类型的 R 对象，它们的维数
不同，并且它们可以存储单个或多个数据
类型：

- **`向量`**：一维（有长度），单一类型的数据。
- **`矩阵`**：二维，单一类型的数据。
- **`data.frame`**：两个维度，每列一种类型。

## 列表

我们还没有见过这种数据类型，但了解它很有用，并且根据我们刚刚看到的总结，
是列表：

- **`列表`**：一维，每个项目可以是不同的数据
  类型。

下面，让我们创建一个包含数字、字符、
矩阵、数据框和另一个列表的向量列表：

```{r list0, purl=TRUE}
l <- list(1:10, ## 数字
          字母, ## 字符
          installed.packages(), ## 矩阵
          汽车, ## 数据框
          list(1, 2, 3)) ## 列表
长度(l)
str(l)
```

列表子集化是使用 `[]` 来子集化新的子列表或使用 `[[]]`
来提取该列表的单个元素（使用索引或名称，如果
列表已命名）。

```{r, purl=TRUE}
l[[1]] ## 第一个元素
l[1:2] ## 长度为 2 的列表
l[1] ## 长度为 1 的列表
```

## 导出和保存表格数据 {#sec:exportandsave}

我们已经了解了如何使用
`read.table` 系列函数将基于文本的电子表格读入 R。 要将 `data.frame` 导出到
基于文本的电子表格，我们可以使用 `write.table` 函数集
(`write.csv`、`write.delim`，...)。 它们都将要导出的变量
和要导出到的文件。 例如，要将
`rna` 数据导出到 `data_output`
目录中的 `my_rna.csv` 文件，我们可以执行：

```{r, eval=FALSE, purl=TRUE}
写入.csv（rna，文件 = “data_output/my_rna.csv”）
```

This new csv file can now be shared with other collaborators who
aren't familiar with R. Note that even though there are commas in some of
the fields in the `data.frame` (see for example the "product" column), R will
by default surround each field with quotes, and thus we will be able to
read it back into R correctly, despite also using commas as column
separators.

:::::::::::::::::::::::::::::::::::::::: keypoints

- R 中的表格数据

:::::::::::::::::::::::::::::::::::::::::::::::::::::
